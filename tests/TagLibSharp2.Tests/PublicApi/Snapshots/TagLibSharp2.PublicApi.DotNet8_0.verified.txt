namespace TagLibSharp2.Aiff
{
    public class AiffAudioProperties : TagLibSharp2.Core.IMediaProperties
    {
        public const int MinAifcCommSize = 22;
        public const int MinCommSize = 18;
        public int Bitrate { get; }
        public int BitsPerSample { get; }
        public int Channels { get; }
        public string? Codec { get; }
        public string? CompressionName { get; }
        public string? CompressionType { get; }
        public System.TimeSpan Duration { get; }
        public uint SampleFrames { get; }
        public int SampleRate { get; }
        public static bool TryParse(TagLibSharp2.Core.BinaryData commData, out TagLibSharp2.Aiff.AiffAudioProperties? properties) { }
    }
    public class AiffChunk
    {
        public const int HeaderSize = 8;
        public AiffChunk(string fourCC, TagLibSharp2.Core.BinaryData data) { }
        public TagLibSharp2.Core.BinaryData Data { get; }
        public string FourCC { get; }
        public uint Size { get; }
        public int TotalSize { get; }
        public TagLibSharp2.Core.BinaryData Render() { }
        public static bool TryParse(TagLibSharp2.Core.BinaryData data, int offset, out TagLibSharp2.Aiff.AiffChunk? chunk) { }
    }
    public sealed class AiffFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public const int HeaderSize = 12;
        public static readonly TagLibSharp2.Core.BinaryData AifcType;
        public static readonly TagLibSharp2.Core.BinaryData AiffType;
        public static readonly TagLibSharp2.Core.BinaryData FormMagic;
        public AiffFile() { }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Aiff.AiffChunk> AllChunks { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.PictureFrame? CoverArt { get; }
        public uint FileSize { get; }
        public string FormType { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public bool HasPictures { get; }
        public bool IsValid { get; }
        public TagLibSharp2.Core.IPicture[] Pictures { get; }
        public TagLibSharp2.Aiff.AiffAudioProperties? Properties { get; }
        public string? SourcePath { get; }
        public TagLibSharp2.Id3.Id3v2.Id3v2Tag? Tag { get; set; }
        public void Dispose() { }
        public TagLibSharp2.Aiff.AiffChunk? GetChunk(string fourCC) { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Aiff.AiffFileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Aiff.AiffFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Aiff.AiffFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Aiff.AiffFile? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Aiff.AiffFile? file) { }
    }
    public readonly struct AiffFileReadResult : System.IEquatable<TagLibSharp2.Aiff.AiffFileReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Aiff.AiffFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Aiff.AiffFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Aiff.AiffFileReadResult Failure(string error) { }
        public static TagLibSharp2.Aiff.AiffFileReadResult Success(TagLibSharp2.Aiff.AiffFile file) { }
        public static bool operator !=(TagLibSharp2.Aiff.AiffFileReadResult left, TagLibSharp2.Aiff.AiffFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Aiff.AiffFileReadResult left, TagLibSharp2.Aiff.AiffFileReadResult right) { }
    }
}
namespace TagLibSharp2.Ape
{
    public sealed class ApeBinaryData
    {
        public ApeBinaryData(string filename, byte[] data) { }
        public byte[] Data { get; }
        public string Filename { get; }
    }
    public enum ApeItemType
    {
        Text = 0,
        Binary = 1,
        ExternalLocator = 2,
        Reserved = 3,
    }
    public sealed class ApePicture : TagLibSharp2.Core.Picture
    {
        public const string ArtistKey = "Cover Art (Artist)";
        public const string BackCoverKey = "Cover Art (Back)";
        public const string FrontCoverKey = "Cover Art (Front)";
        public const string MediaKey = "Cover Art (Media)";
        public ApePicture(string filename, TagLibSharp2.Core.PictureType pictureType, TagLibSharp2.Core.BinaryData pictureData) { }
        public ApePicture(string mimeType, TagLibSharp2.Core.PictureType pictureType, string filename, TagLibSharp2.Core.BinaryData pictureData) { }
        public override string Description { get; }
        public string Filename { get; }
        public override string MimeType { get; }
        public override TagLibSharp2.Core.BinaryData PictureData { get; }
        public override TagLibSharp2.Core.PictureType PictureType { get; }
        public string GetKey() { }
        public static TagLibSharp2.Ape.ApePicture FromBinaryData(string key, TagLibSharp2.Ape.ApeBinaryData data) { }
        public static TagLibSharp2.Ape.ApePicture FromPicture(TagLibSharp2.Core.IPicture picture) { }
        public static string GetKeyForPictureType(TagLibSharp2.Core.PictureType type) { }
        public static TagLibSharp2.Core.PictureType GetPictureTypeForKey(string key) { }
    }
    public sealed class ApeTag : TagLibSharp2.Core.Tag
    {
        public ApeTag() { }
        public override string? AcoustIdFingerprint { get; set; }
        public override string? AcoustIdId { get; set; }
        public override string? Album { get; set; }
        public override string? AlbumArtist { get; set; }
        public override string? AlbumArtistSort { get; set; }
        public override string? AlbumSort { get; set; }
        public override string? AmazonId { get; set; }
        public override string? Artist { get; set; }
        public override string? ArtistSort { get; set; }
        public override string? Barcode { get; set; }
        public override uint? BeatsPerMinute { get; set; }
        public override string? CatalogNumber { get; set; }
        public override string? Comment { get; set; }
        public override string? Composer { get; set; }
        public override string? ComposerSort { get; set; }
        public override string? Conductor { get; set; }
        public override string? Copyright { get; set; }
        public override string? DateTagged { get; set; }
        public override string? Description { get; set; }
        public uint? Disc { get; set; }
        public override uint? DiscNumber { get; set; }
        public override string? DiscSubtitle { get; set; }
        public override string? EncodedBy { get; set; }
        public override string? EncoderSettings { get; set; }
        public override string? Genre { get; set; }
        public override string? Grouping { get; set; }
        public override string? InitialKey { get; set; }
        public override bool IsCompilation { get; set; }
        public override string? Isrc { get; set; }
        public int ItemCount { get; }
        public override string? Language { get; set; }
        public override string? Lyrics { get; set; }
        public override string? MediaType { get; set; }
        public override string? Mood { get; set; }
        public override string? Movement { get; set; }
        public override uint? MovementNumber { get; set; }
        public override uint? MovementTotal { get; set; }
        public override string? MusicBrainzAlbumArtistId { get; set; }
        public override string? MusicBrainzArtistId { get; set; }
        public override string? MusicBrainzDiscId { get; set; }
        public override string? MusicBrainzRecordingId { get; set; }
        public override string? MusicBrainzReleaseCountry { get; set; }
        public override string? MusicBrainzReleaseGroupId { get; set; }
        public override string? MusicBrainzReleaseId { get; set; }
        public override string? MusicBrainzReleaseStatus { get; set; }
        public override string? MusicBrainzReleaseType { get; set; }
        public override string? MusicBrainzTrackId { get; set; }
        public override string? MusicBrainzWorkId { get; set; }
        public override string? OriginalReleaseDate { get; set; }
        public override TagLibSharp2.Core.IPicture[] Pictures { get; set; }
        public override string? PodcastFeedUrl { get; set; }
        public override string? Publisher { get; set; }
        public override string? R128AlbumGain { get; set; }
        public override string? R128TrackGain { get; set; }
        public override string? Remixer { get; set; }
        public override string? ReplayGainAlbumGain { get; set; }
        public override string? ReplayGainAlbumPeak { get; set; }
        public override string? ReplayGainTrackGain { get; set; }
        public override string? ReplayGainTrackPeak { get; set; }
        public override string? Subtitle { get; set; }
        public override TagLibSharp2.Core.TagTypes TagType { get; }
        public override string? Title { get; set; }
        public override string? TitleSort { get; set; }
        public override uint? TotalDiscs { get; set; }
        public override uint? TotalTracks { get; set; }
        public override uint? Track { get; set; }
        public override string? Work { get; set; }
        public override string? Year { get; set; }
        public override void Clear() { }
        public TagLibSharp2.Ape.ApeBinaryData? GetBinaryItem(string key) { }
        public string? GetValue(string key) { }
        public bool Remove(string key) { }
        public override TagLibSharp2.Core.BinaryData Render() { }
        public TagLibSharp2.Core.BinaryData RenderWithOptions(bool includeHeader = false) { }
        public void SetBinaryItem(string key, string filename, byte[] data) { }
        public void SetValue(string key, string value) { }
        public static TagLibSharp2.Ape.ApeTagParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public sealed class ApeTagFooter
    {
        public const int Size = 32;
        public uint Flags { get; }
        public bool HasFooter { get; }
        public bool HasHeader { get; }
        public bool IsHeader { get; }
        public bool IsReadOnly { get; }
        public uint ItemCount { get; }
        public uint TagSize { get; }
        public uint Version { get; }
        public static System.ReadOnlySpan<byte> Magic { get; }
        public byte[] Render() { }
        public static TagLibSharp2.Ape.ApeTagFooter Create(uint tagSize, uint itemCount, bool isHeader = false, bool hasHeader = false, bool isReadOnly = false) { }
        public static TagLibSharp2.Ape.ApeTagFooterParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct ApeTagFooterParseResult : System.IEquatable<TagLibSharp2.Ape.ApeTagFooterParseResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Ape.ApeTagFooter? Footer { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Ape.ApeTagFooterParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Ape.ApeTagFooterParseResult Failure(string error) { }
        public static TagLibSharp2.Ape.ApeTagFooterParseResult Success(TagLibSharp2.Ape.ApeTagFooter footer) { }
        public static bool operator !=(TagLibSharp2.Ape.ApeTagFooterParseResult left, TagLibSharp2.Ape.ApeTagFooterParseResult right) { }
        public static bool operator ==(TagLibSharp2.Ape.ApeTagFooterParseResult left, TagLibSharp2.Ape.ApeTagFooterParseResult right) { }
    }
    public sealed class ApeTagHeader
    {
        public const int Size = 32;
        public uint Flags { get; }
        public bool HasHeader { get; }
        public bool IsHeader { get; }
        public bool IsReadOnly { get; }
        public uint ItemCount { get; }
        public uint TagSize { get; }
        public uint Version { get; }
        public byte[] Render() { }
        public static TagLibSharp2.Ape.ApeTagHeader Create(uint tagSize, uint itemCount, bool isReadOnly = false) { }
        public static TagLibSharp2.Ape.ApeTagHeaderParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct ApeTagHeaderParseResult : System.IEquatable<TagLibSharp2.Ape.ApeTagHeaderParseResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Ape.ApeTagHeader? Header { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Ape.ApeTagHeaderParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Ape.ApeTagHeaderParseResult Failure(string error) { }
        public static TagLibSharp2.Ape.ApeTagHeaderParseResult Success(TagLibSharp2.Ape.ApeTagHeader header) { }
        public static bool operator !=(TagLibSharp2.Ape.ApeTagHeaderParseResult left, TagLibSharp2.Ape.ApeTagHeaderParseResult right) { }
        public static bool operator ==(TagLibSharp2.Ape.ApeTagHeaderParseResult left, TagLibSharp2.Ape.ApeTagHeaderParseResult right) { }
    }
    public sealed class ApeTagItem
    {
        public const int MaxKeyLength = 255;
        public const int MinHeaderSize = 8;
        public const int MinKeyLength = 2;
        public TagLibSharp2.Ape.ApeBinaryData? BinaryValue { get; }
        public uint Flags { get; }
        public bool IsReadOnly { get; }
        public TagLibSharp2.Ape.ApeItemType ItemType { get; }
        public string Key { get; }
        public byte[] RawValue { get; }
        public string? ValueAsString { get; }
        public byte[] Render() { }
        public static TagLibSharp2.Ape.ApeTagItem CreateBinary(string key, string filename, byte[] data, bool isReadOnly = false) { }
        public static TagLibSharp2.Ape.ApeTagItem CreateExternalLocator(string key, string url, bool isReadOnly = false) { }
        public static TagLibSharp2.Ape.ApeTagItem CreateText(string key, string value, bool isReadOnly = false) { }
        public static TagLibSharp2.Ape.ApeTagItemParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct ApeTagItemParseResult : System.IEquatable<TagLibSharp2.Ape.ApeTagItemParseResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Ape.ApeTagItem? Item { get; }
        public bool Equals(TagLibSharp2.Ape.ApeTagItemParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Ape.ApeTagItemParseResult Failure(string error) { }
        public static TagLibSharp2.Ape.ApeTagItemParseResult Success(TagLibSharp2.Ape.ApeTagItem item, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Ape.ApeTagItemParseResult left, TagLibSharp2.Ape.ApeTagItemParseResult right) { }
        public static bool operator ==(TagLibSharp2.Ape.ApeTagItemParseResult left, TagLibSharp2.Ape.ApeTagItemParseResult right) { }
    }
    public readonly struct ApeTagParseResult : System.IEquatable<TagLibSharp2.Ape.ApeTagParseResult>
    {
        public string? Error { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Ape.ApeTag? Tag { get; }
        public bool Equals(TagLibSharp2.Ape.ApeTagParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Ape.ApeTagParseResult Failure(string error) { }
        public static TagLibSharp2.Ape.ApeTagParseResult Success(TagLibSharp2.Ape.ApeTag tag) { }
        public static bool operator !=(TagLibSharp2.Ape.ApeTagParseResult left, TagLibSharp2.Ape.ApeTagParseResult right) { }
        public static bool operator ==(TagLibSharp2.Ape.ApeTagParseResult left, TagLibSharp2.Ape.ApeTagParseResult right) { }
    }
    public sealed class MonkeysAudioFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public TagLibSharp2.Ape.ApeTag? ApeTag { get; }
        public int BitsPerSample { get; }
        public uint BlocksPerFrame { get; }
        public int Channels { get; }
        public int CompressionLevel { get; }
        public uint FinalFrameBlocks { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public TagLibSharp2.Core.AudioProperties Properties { get; }
        public int SampleRate { get; }
        public string? SourcePath { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public uint TotalFrames { get; }
        public int Version { get; }
        public void Dispose() { }
        public TagLibSharp2.Ape.ApeTag EnsureApeTag() { }
        public void RemoveApeTag() { }
        public byte[] Render(System.ReadOnlySpan<byte> originalData) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Ape.MonkeysAudioFileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Ape.MonkeysAudioFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Ape.MonkeysAudioFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Ape.MonkeysAudioFile? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Ape.MonkeysAudioFile? file) { }
    }
    public readonly struct MonkeysAudioFileReadResult : System.IEquatable<TagLibSharp2.Ape.MonkeysAudioFileReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Ape.MonkeysAudioFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Ape.MonkeysAudioFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Ape.MonkeysAudioFileReadResult Failure(string error) { }
        public static TagLibSharp2.Ape.MonkeysAudioFileReadResult Success(TagLibSharp2.Ape.MonkeysAudioFile file) { }
        public static bool operator !=(TagLibSharp2.Ape.MonkeysAudioFileReadResult left, TagLibSharp2.Ape.MonkeysAudioFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Ape.MonkeysAudioFileReadResult left, TagLibSharp2.Ape.MonkeysAudioFileReadResult right) { }
    }
}
namespace TagLibSharp2.Asf
{
    public enum AsfAttributeType
    {
        UnicodeString = 0,
        Binary = 1,
        Bool = 2,
        Dword = 3,
        Qword = 4,
        Word = 5,
        UniqueId = 6,
    }
    public sealed class AsfContentDescription
    {
        public AsfContentDescription(string title, string author, string copyright, string description, string rating) { }
        public string Author { get; }
        public string Copyright { get; }
        public string Description { get; }
        public string Rating { get; }
        public string Title { get; }
        public TagLibSharp2.Core.BinaryData Render() { }
        public static TagLibSharp2.Asf.AsfContentDescriptionParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct AsfContentDescriptionParseResult : System.IEquatable<TagLibSharp2.Asf.AsfContentDescriptionParseResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Asf.AsfContentDescription Value { get; }
        public bool Equals(TagLibSharp2.Asf.AsfContentDescriptionParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Asf.AsfContentDescriptionParseResult Failure(string error) { }
        public static TagLibSharp2.Asf.AsfContentDescriptionParseResult Success(TagLibSharp2.Asf.AsfContentDescription value, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Asf.AsfContentDescriptionParseResult left, TagLibSharp2.Asf.AsfContentDescriptionParseResult right) { }
        public static bool operator ==(TagLibSharp2.Asf.AsfContentDescriptionParseResult left, TagLibSharp2.Asf.AsfContentDescriptionParseResult right) { }
    }
    public sealed class AsfDescriptor
    {
        public TagLibSharp2.Core.BinaryData? BinaryValue { get; }
        public bool? BoolValue { get; }
        public uint? DwordValue { get; }
        public ushort LanguageIndex { get; }
        public string Name { get; }
        public ulong? QwordValue { get; }
        public TagLibSharp2.Core.BinaryData RawValue { get; }
        public ushort StreamNumber { get; }
        public string? StringValue { get; }
        public TagLibSharp2.Asf.AsfAttributeType Type { get; }
        public ushort? WordValue { get; }
        public TagLibSharp2.Core.BinaryData RenderName() { }
        public TagLibSharp2.Core.BinaryData RenderValue() { }
        public static TagLibSharp2.Asf.AsfDescriptor CreateBinary(string name, TagLibSharp2.Core.BinaryData value) { }
        public static TagLibSharp2.Asf.AsfDescriptor CreateBinary(string name, byte[] value) { }
        public static TagLibSharp2.Asf.AsfDescriptor CreateBool(string name, bool value) { }
        public static TagLibSharp2.Asf.AsfDescriptor CreateDword(string name, uint value) { }
        public static TagLibSharp2.Asf.AsfDescriptor CreateQword(string name, ulong value) { }
        public static TagLibSharp2.Asf.AsfDescriptor CreateString(string name, string value) { }
        public static TagLibSharp2.Asf.AsfDescriptor CreateWord(string name, ushort value) { }
    }
    public sealed class AsfExtendedContentDescription
    {
        public AsfExtendedContentDescription(System.Collections.Generic.IReadOnlyList<TagLibSharp2.Asf.AsfDescriptor> descriptors) { }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Asf.AsfDescriptor> Descriptors { get; }
        public bool? GetBool(string name) { }
        public TagLibSharp2.Asf.AsfDescriptor? GetDescriptor(string name) { }
        public uint? GetDword(string name) { }
        public ulong? GetQword(string name) { }
        public string? GetString(string name) { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public static TagLibSharp2.Asf.AsfExtendedContentDescriptionParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct AsfExtendedContentDescriptionParseResult : System.IEquatable<TagLibSharp2.Asf.AsfExtendedContentDescriptionParseResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Asf.AsfExtendedContentDescription Value { get; }
        public bool Equals(TagLibSharp2.Asf.AsfExtendedContentDescriptionParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Asf.AsfExtendedContentDescriptionParseResult Failure(string error) { }
        public static TagLibSharp2.Asf.AsfExtendedContentDescriptionParseResult Success(TagLibSharp2.Asf.AsfExtendedContentDescription value, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Asf.AsfExtendedContentDescriptionParseResult left, TagLibSharp2.Asf.AsfExtendedContentDescriptionParseResult right) { }
        public static bool operator ==(TagLibSharp2.Asf.AsfExtendedContentDescriptionParseResult left, TagLibSharp2.Asf.AsfExtendedContentDescriptionParseResult right) { }
    }
    public sealed class AsfFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public string? Album { get; set; }
        public string? Artist { get; set; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public TagLibSharp2.Core.AudioProperties Properties { get; }
        public string? SourcePath { get; }
        public TagLibSharp2.Asf.AsfTag Tag { get; }
        public string? Title { get; set; }
        public void Dispose() { }
        public byte[] Render(System.ReadOnlySpan<byte> originalData) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Asf.AsfFileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Asf.AsfFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Asf.AsfFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Asf.AsfFile? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Asf.AsfFile? file) { }
    }
    public sealed class AsfFileProperties
    {
        public const int MinContentSize = 80;
        public ulong CreationDateFiletime { get; }
        public ulong DataPacketsCount { get; }
        public System.TimeSpan Duration { get; }
        public TagLibSharp2.Asf.AsfGuid FileId { get; }
        public ulong FileSize { get; }
        public uint Flags { get; }
        public bool IsSeekable { get; }
        public uint MaxBitrate { get; }
        public uint MaxPacketSize { get; }
        public uint MinPacketSize { get; }
        public ulong PlayDurationNs { get; }
        public ulong PrerollMs { get; }
        public ulong SendDurationNs { get; }
        public static TagLibSharp2.Asf.AsfFilePropertiesParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct AsfFilePropertiesParseResult : System.IEquatable<TagLibSharp2.Asf.AsfFilePropertiesParseResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Asf.AsfFileProperties Value { get; }
        public bool Equals(TagLibSharp2.Asf.AsfFilePropertiesParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Asf.AsfFilePropertiesParseResult Failure(string error) { }
        public static TagLibSharp2.Asf.AsfFilePropertiesParseResult Success(TagLibSharp2.Asf.AsfFileProperties value, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Asf.AsfFilePropertiesParseResult left, TagLibSharp2.Asf.AsfFilePropertiesParseResult right) { }
        public static bool operator ==(TagLibSharp2.Asf.AsfFilePropertiesParseResult left, TagLibSharp2.Asf.AsfFilePropertiesParseResult right) { }
    }
    public readonly struct AsfFileReadResult : System.IEquatable<TagLibSharp2.Asf.AsfFileReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Asf.AsfFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Asf.AsfFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Asf.AsfFileReadResult Failure(string error) { }
        public static TagLibSharp2.Asf.AsfFileReadResult Success(TagLibSharp2.Asf.AsfFile file) { }
        public static bool operator !=(TagLibSharp2.Asf.AsfFileReadResult left, TagLibSharp2.Asf.AsfFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Asf.AsfFileReadResult left, TagLibSharp2.Asf.AsfFileReadResult right) { }
    }
    public readonly struct AsfGuid : System.IEquatable<TagLibSharp2.Asf.AsfGuid>
    {
        public const int Size = 16;
        public bool Equals(TagLibSharp2.Asf.AsfGuid other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public static TagLibSharp2.Asf.AsfGuidParseResult Parse(System.ReadOnlySpan<byte> data) { }
        public static bool operator !=(TagLibSharp2.Asf.AsfGuid left, TagLibSharp2.Asf.AsfGuid right) { }
        public static bool operator ==(TagLibSharp2.Asf.AsfGuid left, TagLibSharp2.Asf.AsfGuid right) { }
    }
    public readonly struct AsfGuidParseResult : System.IEquatable<TagLibSharp2.Asf.AsfGuidParseResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Asf.AsfGuid Value { get; }
        public bool Equals(TagLibSharp2.Asf.AsfGuidParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Asf.AsfGuidParseResult Failure(string error) { }
        public static TagLibSharp2.Asf.AsfGuidParseResult Success(TagLibSharp2.Asf.AsfGuid value, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Asf.AsfGuidParseResult left, TagLibSharp2.Asf.AsfGuidParseResult right) { }
        public static bool operator ==(TagLibSharp2.Asf.AsfGuidParseResult left, TagLibSharp2.Asf.AsfGuidParseResult right) { }
    }
    public static class AsfGuids
    {
        public static readonly TagLibSharp2.Asf.AsfGuid AudioMediaType;
        public static readonly TagLibSharp2.Asf.AsfGuid AudioSpread;
        public static readonly TagLibSharp2.Asf.AsfGuid CodecListObject;
        public static readonly TagLibSharp2.Asf.AsfGuid ContentDescriptionObject;
        public static readonly TagLibSharp2.Asf.AsfGuid DataObject;
        public static readonly TagLibSharp2.Asf.AsfGuid ExtendedContentDescriptionObject;
        public static readonly TagLibSharp2.Asf.AsfGuid ExtendedStreamPropertiesObject;
        public static readonly TagLibSharp2.Asf.AsfGuid FilePropertiesObject;
        public static readonly TagLibSharp2.Asf.AsfGuid HeaderExtensionObject;
        public static readonly TagLibSharp2.Asf.AsfGuid HeaderObject;
        public static readonly TagLibSharp2.Asf.AsfGuid LanguageListObject;
        public static readonly TagLibSharp2.Asf.AsfGuid MetadataLibraryObject;
        public static readonly TagLibSharp2.Asf.AsfGuid MetadataObject;
        public static readonly TagLibSharp2.Asf.AsfGuid NoErrorCorrection;
        public static readonly TagLibSharp2.Asf.AsfGuid PaddingObject;
        public static readonly TagLibSharp2.Asf.AsfGuid SimpleIndexObject;
        public static readonly TagLibSharp2.Asf.AsfGuid StreamBitratePropertiesObject;
        public static readonly TagLibSharp2.Asf.AsfGuid StreamPropertiesObject;
        public static readonly TagLibSharp2.Asf.AsfGuid VideoMediaType;
    }
    public sealed class AsfPicture : TagLibSharp2.Core.Picture
    {
        public const string AttributeName = "WM/Picture";
        public AsfPicture(string mimeType, TagLibSharp2.Core.PictureType pictureType, string description, TagLibSharp2.Core.BinaryData pictureData) { }
        public override string Description { get; }
        public override string MimeType { get; }
        public override TagLibSharp2.Core.BinaryData PictureData { get; }
        public override TagLibSharp2.Core.PictureType PictureType { get; }
        public TagLibSharp2.Core.BinaryData Render() { }
        public static TagLibSharp2.Asf.AsfPicture FromPicture(TagLibSharp2.Core.IPicture picture) { }
        public static TagLibSharp2.Asf.AsfPicture? Parse(System.ReadOnlySpan<byte> data) { }
    }
    public sealed class AsfStreamProperties
    {
        public const int MinContentSize = 54;
        public uint AvgBytesPerSec { get; }
        public int BitsPerSample { get; }
        public int BlockAlign { get; }
        public int Channels { get; }
        public int CodecId { get; }
        public string CodecName { get; }
        public TagLibSharp2.Asf.AsfGuid ErrorCorrectionType { get; }
        public bool IsAudio { get; }
        public bool IsVideo { get; }
        public uint SampleRate { get; }
        public int StreamNumber { get; }
        public TagLibSharp2.Asf.AsfGuid StreamType { get; }
        public ulong TimeOffset { get; }
        public static TagLibSharp2.Asf.AsfStreamPropertiesParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct AsfStreamPropertiesParseResult : System.IEquatable<TagLibSharp2.Asf.AsfStreamPropertiesParseResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Asf.AsfStreamProperties Value { get; }
        public bool Equals(TagLibSharp2.Asf.AsfStreamPropertiesParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Asf.AsfStreamPropertiesParseResult Failure(string error) { }
        public static TagLibSharp2.Asf.AsfStreamPropertiesParseResult Success(TagLibSharp2.Asf.AsfStreamProperties value, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Asf.AsfStreamPropertiesParseResult left, TagLibSharp2.Asf.AsfStreamPropertiesParseResult right) { }
        public static bool operator ==(TagLibSharp2.Asf.AsfStreamPropertiesParseResult left, TagLibSharp2.Asf.AsfStreamPropertiesParseResult right) { }
    }
    public sealed class AsfTag : TagLibSharp2.Core.Tag
    {
        public AsfTag() { }
        public AsfTag(TagLibSharp2.Asf.AsfContentDescription? contentDescription, TagLibSharp2.Asf.AsfExtendedContentDescription? extendedContent) { }
        public override string? AcoustIdFingerprint { get; set; }
        public override string? AcoustIdId { get; set; }
        public override string? Album { get; set; }
        public override string? AlbumArtist { get; set; }
        public override string? AlbumArtistSort { get; set; }
        public override string? AlbumSort { get; set; }
        public override string? AmazonId { get; set; }
        public override string? Artist { get; set; }
        public override string? ArtistSort { get; set; }
        public override string? Barcode { get; set; }
        public override uint? BeatsPerMinute { get; set; }
        public override string? CatalogNumber { get; set; }
        public override string? Comment { get; set; }
        public override string? Composer { get; set; }
        public override string? ComposerSort { get; set; }
        public override string? Conductor { get; set; }
        public TagLibSharp2.Asf.AsfContentDescription ContentDescription { get; }
        public override string? Copyright { get; set; }
        public override string? DateTagged { get; set; }
        public override string? Description { get; set; }
        public uint? DiscCount { get; }
        public override uint? DiscNumber { get; set; }
        public override string? EncodedBy { get; set; }
        public override string? EncoderSettings { get; set; }
        public TagLibSharp2.Asf.AsfExtendedContentDescription ExtendedContentDescription { get; }
        public override string? Genre { get; set; }
        public override string? Grouping { get; set; }
        public override string? InitialKey { get; set; }
        public override bool IsCompilation { get; set; }
        public override bool IsEmpty { get; }
        public override string? Isrc { get; set; }
        public override string? Language { get; set; }
        public override string? Lyrics { get; set; }
        public override string? MediaType { get; set; }
        public override string? Mood { get; set; }
        public override string? Movement { get; set; }
        public override uint? MovementNumber { get; set; }
        public override uint? MovementTotal { get; set; }
        public override string? MusicBrainzAlbumArtistId { get; set; }
        public override string? MusicBrainzArtistId { get; set; }
        public override string? MusicBrainzDiscId { get; set; }
        public override string? MusicBrainzRecordingId { get; set; }
        public override string? MusicBrainzReleaseCountry { get; set; }
        public override string? MusicBrainzReleaseGroupId { get; set; }
        public override string? MusicBrainzReleaseId { get; set; }
        public override string? MusicBrainzReleaseStatus { get; set; }
        public override string? MusicBrainzReleaseType { get; set; }
        public override string? MusicBrainzTrackId { get; set; }
        public override string? MusicBrainzWorkId { get; set; }
        public override string? OriginalReleaseDate { get; set; }
        public override TagLibSharp2.Core.IPicture[] Pictures { get; set; }
        public override string? PodcastFeedUrl { get; set; }
        public override string? Publisher { get; set; }
        public override string? R128AlbumGain { get; set; }
        public override string? R128TrackGain { get; set; }
        public string Rating { get; set; }
        public override string? Remixer { get; set; }
        public override string? ReplayGainAlbumGain { get; set; }
        public override string? ReplayGainAlbumPeak { get; set; }
        public override string? ReplayGainTrackGain { get; set; }
        public override string? ReplayGainTrackPeak { get; set; }
        public override string? Subtitle { get; set; }
        public override TagLibSharp2.Core.TagTypes TagType { get; }
        public override string? Title { get; set; }
        public override string? TitleSort { get; set; }
        public override uint? TotalDiscs { get; set; }
        public override uint? TotalTracks { get; set; }
        public override uint? Track { get; set; }
        public override string? Work { get; set; }
        public override string? Year { get; set; }
        public override void Clear() { }
        public override TagLibSharp2.Core.BinaryData Render() { }
        public TagLibSharp2.Core.BinaryData RenderContentDescription() { }
    }
}
namespace TagLibSharp2.Core
{
    public static class AtomicFileWriter
    {
        public static TagLibSharp2.Core.FileWriteResult Write(string path, System.ReadOnlySpan<byte> data, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> WriteAsync(string path, System.ReadOnlyMemory<byte> data, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public readonly struct AudioProperties : System.IEquatable<TagLibSharp2.Core.AudioProperties>, TagLibSharp2.Core.IMediaProperties
    {
        public AudioProperties(System.TimeSpan Duration, int Bitrate, int SampleRate, int BitsPerSample, int Channels, string? Codec = null) { }
        public int Bitrate { get; init; }
        public int BitsPerSample { get; init; }
        public int Channels { get; init; }
        public string? Codec { get; init; }
        public System.TimeSpan Duration { get; init; }
        public bool IsValid { get; }
        public int SampleRate { get; init; }
        public static TagLibSharp2.Core.AudioProperties Empty { get; }
        public override string ToString() { }
        public static TagLibSharp2.Core.AudioProperties FromDff(System.TimeSpan duration, int sampleRate, int channels, bool isDst = false) { }
        public static TagLibSharp2.Core.AudioProperties FromDsf(System.TimeSpan duration, int sampleRate, int channels) { }
        public static TagLibSharp2.Core.AudioProperties FromFlac(ulong totalSamples, int sampleRate, int bitsPerSample, int channels) { }
        public static TagLibSharp2.Core.AudioProperties FromOpus(ulong granulePosition, ushort preSkip, uint inputSampleRate, int channels, long fileSize) { }
        public static TagLibSharp2.Core.AudioProperties FromVorbis(ulong totalSamples, int sampleRate, int channels, int bitrateNominal) { }
    }
    public static class BatchProcessor
    {
        public static int DefaultMaxDegreeOfParallelism { get; set; }
        public static System.Collections.Generic.IReadOnlyList<TagLibSharp2.Core.BatchResult<T>> Process<T>(System.Collections.Generic.IEnumerable<string> paths, System.Func<string, T> operation, int? maxDegreeOfParallelism = default, System.IProgress<TagLibSharp2.Core.BatchProgress>? progress = null) { }
        public static System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<TagLibSharp2.Core.BatchResult<T>>> ProcessAsync<T>(System.Collections.Generic.IEnumerable<string> paths, System.Func<string, System.Threading.CancellationToken, System.Threading.Tasks.Task<T>> operation, int? maxDegreeOfParallelism = default, System.IProgress<TagLibSharp2.Core.BatchProgress>? progress = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<TagLibSharp2.Core.BatchResult<bool>>> TransformTagsAsync<TFile, TTag>(System.Collections.Generic.IEnumerable<string> paths, [System.Runtime.CompilerServices.TupleElementNames(new string[] {
                "file",
                "tag"})] System.Func<string, System.Threading.CancellationToken, System.Threading.Tasks.Task<System.ValueTuple<TFile, TTag>?>> readFile, System.Action<TTag> transform, System.Func<TFile, string, System.Threading.CancellationToken, System.Threading.Tasks.Task> saveFile, int? maxDegreeOfParallelism = default, System.IProgress<TagLibSharp2.Core.BatchProgress>? progress = null, System.Threading.CancellationToken cancellationToken = default)
            where TTag : TagLibSharp2.Core.Tag { }
    }
    public readonly struct BatchProgress : System.IEquatable<TagLibSharp2.Core.BatchProgress>
    {
        public BatchProgress(int completed, int total, string currentPath) { }
        public int Completed { get; }
        public string CurrentPath { get; }
        public double PercentComplete { get; }
        public int Total { get; }
        public bool Equals(TagLibSharp2.Core.BatchProgress other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static bool operator !=(TagLibSharp2.Core.BatchProgress left, TagLibSharp2.Core.BatchProgress right) { }
        public static bool operator ==(TagLibSharp2.Core.BatchProgress left, TagLibSharp2.Core.BatchProgress right) { }
    }
    public static class BatchResultExtensions
    {
        public static int FailureCount<T>(this System.Collections.Generic.IEnumerable<TagLibSharp2.Core.BatchResult<T>> results) { }
        public static int SuccessCount<T>(this System.Collections.Generic.IEnumerable<TagLibSharp2.Core.BatchResult<T>> results) { }
        public static System.Collections.Generic.IEnumerable<TagLibSharp2.Core.BatchResult<T>> WhereFailed<T>(this System.Collections.Generic.IEnumerable<TagLibSharp2.Core.BatchResult<T>> results) { }
        public static System.Collections.Generic.IEnumerable<TagLibSharp2.Core.BatchResult<T>> WhereSucceeded<T>(this System.Collections.Generic.IEnumerable<TagLibSharp2.Core.BatchResult<T>> results) { }
    }
    public readonly struct BatchResult<T> : System.IEquatable<TagLibSharp2.Core.BatchResult<T>>
    {
        public System.Exception? Error { get; }
        public bool IsCancelled { get; }
        public bool IsSuccess { get; }
        public string Path { get; }
        public T Value { get; }
        public bool Equals(TagLibSharp2.Core.BatchResult<T> other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Core.BatchResult<T> Cancelled(string path) { }
        public static TagLibSharp2.Core.BatchResult<T> Failure(string path, System.Exception error) { }
        public static TagLibSharp2.Core.BatchResult<T> Success(string path, T value) { }
        public static bool operator !=(TagLibSharp2.Core.BatchResult<T> left, TagLibSharp2.Core.BatchResult<T> right) { }
        public static bool operator ==(TagLibSharp2.Core.BatchResult<T> left, TagLibSharp2.Core.BatchResult<T> right) { }
    }
    public readonly struct BinaryData : System.Collections.Generic.IEnumerable<byte>, System.Collections.Generic.IReadOnlyCollection<byte>, System.Collections.Generic.IReadOnlyList<byte>, System.Collections.IEnumerable, System.IComparable<TagLibSharp2.Core.BinaryData>, System.IEquatable<TagLibSharp2.Core.BinaryData>
    {
        public BinaryData(System.ReadOnlySpan<byte> data) { }
        public BinaryData(byte[] data) { }
        public BinaryData(int length, byte fill = 0) { }
        public int Count { get; }
        public bool IsEmpty { get; }
        public byte this[int index] { get; }
        public TagLibSharp2.Core.BinaryData this[System.Range range] { get; }
        public int Length { get; }
        public System.ReadOnlyMemory<byte> Memory { get; }
        public System.ReadOnlySpan<byte> Span { get; }
        public static TagLibSharp2.Core.BinaryData Empty { get; }
        public TagLibSharp2.Core.BinaryData Add(TagLibSharp2.Core.BinaryData other) { }
        public int CompareTo(TagLibSharp2.Core.BinaryData other) { }
        public ushort ComputeCrc16Ccitt() { }
        public uint ComputeCrc32() { }
        public byte ComputeCrc8() { }
        public bool Contains(System.ReadOnlySpan<byte> pattern) { }
        public bool Contains(byte value) { }
        public bool EndsWith(System.ReadOnlySpan<byte> pattern) { }
        public bool Equals(TagLibSharp2.Core.BinaryData other) { }
        public override bool Equals(object? obj) { }
        public System.Collections.Generic.IEnumerator<byte> GetEnumerator() { }
        public override int GetHashCode() { }
        public int IndexOf(System.ReadOnlySpan<byte> pattern, int startIndex = 0) { }
        public int IndexOf(byte value, int startIndex = 0) { }
        public int LastIndexOf(System.ReadOnlySpan<byte> pattern) { }
        public int LastIndexOf(byte value) { }
        public TagLibSharp2.Core.BinaryData PadLeft(int length, byte padByte = 0) { }
        public TagLibSharp2.Core.BinaryData PadRight(int length, byte padByte = 0) { }
        public TagLibSharp2.Core.BinaryData Resize(int length, byte padByte = 0) { }
        public TagLibSharp2.Core.BinaryData Slice(int start) { }
        public TagLibSharp2.Core.BinaryData Slice(int start, int length) { }
        public bool StartsWith(System.ReadOnlySpan<byte> pattern) { }
        public byte[] ToArray() { }
        public string ToHexString() { }
        public string ToHexStringUpper() { }
        public short ToInt16BE(int offset = 0) { }
        public short ToInt16LE(int offset = 0) { }
        public int ToInt32BE(int offset = 0) { }
        public int ToInt32LE(int offset = 0) { }
        public long ToInt64BE(int offset = 0) { }
        public long ToInt64LE(int offset = 0) { }
        public System.ReadOnlySpan<byte> ToReadOnlySpan() { }
        public override string ToString() { }
        public string ToString(System.Text.Encoding encoding) { }
        public string ToStringLatin1() { }
        public string ToStringLatin1NullTerminated() { }
        public string ToStringUtf16() { }
        public string ToStringUtf16NullTerminated() { }
        public string ToStringUtf8() { }
        public string ToStringUtf8NullTerminated() { }
        public uint ToSyncSafeUInt32(int offset = 0) { }
        public ushort ToUInt16BE(int offset = 0) { }
        public ushort ToUInt16LE(int offset = 0) { }
        public uint ToUInt24BE(int offset = 0) { }
        public uint ToUInt32BE(int offset = 0) { }
        public uint ToUInt32LE(int offset = 0) { }
        public ulong ToUInt64BE(int offset = 0) { }
        public ulong ToUInt64LE(int offset = 0) { }
        public TagLibSharp2.Core.BinaryData Trim(byte trimByte = 0) { }
        public TagLibSharp2.Core.BinaryData TrimEnd(byte trimByte = 0) { }
        public TagLibSharp2.Core.BinaryData TrimStart(byte trimByte = 0) { }
        public static TagLibSharp2.Core.BinaryData Concat(params TagLibSharp2.Core.BinaryData[] items) { }
        public static TagLibSharp2.Core.BinaryData FromByteArray(byte[] data) { }
        public static TagLibSharp2.Core.BinaryData FromHexString(string hex) { }
        public static TagLibSharp2.Core.BinaryData FromInt16BE(short value) { }
        public static TagLibSharp2.Core.BinaryData FromInt16LE(short value) { }
        public static TagLibSharp2.Core.BinaryData FromInt32BE(int value) { }
        public static TagLibSharp2.Core.BinaryData FromInt32LE(int value) { }
        public static TagLibSharp2.Core.BinaryData FromInt64BE(long value) { }
        public static TagLibSharp2.Core.BinaryData FromInt64LE(long value) { }
        public static TagLibSharp2.Core.BinaryData FromString(string value, System.Text.Encoding encoding) { }
        public static TagLibSharp2.Core.BinaryData FromStringLatin1(string value) { }
        public static TagLibSharp2.Core.BinaryData FromStringLatin1NullTerminated(string value) { }
        public static TagLibSharp2.Core.BinaryData FromStringUtf16(string value, bool includeBom = true) { }
        public static TagLibSharp2.Core.BinaryData FromStringUtf16NullTerminated(string value, bool includeBom = true) { }
        public static TagLibSharp2.Core.BinaryData FromStringUtf8(string value) { }
        public static TagLibSharp2.Core.BinaryData FromStringUtf8NullTerminated(string value) { }
        public static TagLibSharp2.Core.BinaryData FromSyncSafeUInt32(uint value) { }
        public static TagLibSharp2.Core.BinaryData FromUInt16BE(ushort value) { }
        public static TagLibSharp2.Core.BinaryData FromUInt16LE(ushort value) { }
        public static TagLibSharp2.Core.BinaryData FromUInt24BE(uint value) { }
        public static TagLibSharp2.Core.BinaryData FromUInt32BE(uint value) { }
        public static TagLibSharp2.Core.BinaryData FromUInt32LE(uint value) { }
        public static TagLibSharp2.Core.BinaryData FromUInt64BE(ulong value) { }
        public static TagLibSharp2.Core.BinaryData FromUInt64LE(ulong value) { }
        public static System.ReadOnlySpan<byte> op_Implicit(TagLibSharp2.Core.BinaryData data) { }
        public static TagLibSharp2.Core.BinaryData op_Implicit(byte[] data) { }
        public static bool operator !=(TagLibSharp2.Core.BinaryData left, TagLibSharp2.Core.BinaryData right) { }
        public static TagLibSharp2.Core.BinaryData operator +(TagLibSharp2.Core.BinaryData left, TagLibSharp2.Core.BinaryData right) { }
        public static bool operator <(TagLibSharp2.Core.BinaryData left, TagLibSharp2.Core.BinaryData right) { }
        public static bool operator <=(TagLibSharp2.Core.BinaryData left, TagLibSharp2.Core.BinaryData right) { }
        public static bool operator ==(TagLibSharp2.Core.BinaryData left, TagLibSharp2.Core.BinaryData right) { }
        public static bool operator >(TagLibSharp2.Core.BinaryData left, TagLibSharp2.Core.BinaryData right) { }
        public static bool operator >=(TagLibSharp2.Core.BinaryData left, TagLibSharp2.Core.BinaryData right) { }
    }
    public sealed class BinaryDataBuilder : System.IDisposable
    {
        public BinaryDataBuilder() { }
        public BinaryDataBuilder(int initialCapacity) { }
        public int Capacity { get; }
        public byte this[int index] { get; set; }
        public int Length { get; }
        public System.ReadOnlyMemory<byte> Memory { get; }
        public System.ReadOnlySpan<byte> Span { get; }
        public TagLibSharp2.Core.BinaryDataBuilder Add(System.ReadOnlySpan<byte> data) { }
        public TagLibSharp2.Core.BinaryDataBuilder Add(TagLibSharp2.Core.BinaryData data) { }
        public TagLibSharp2.Core.BinaryDataBuilder Add(params byte[] data) { }
        public TagLibSharp2.Core.BinaryDataBuilder Add(byte value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddFill(byte value, int count) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddInt16BE(short value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddInt16LE(short value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddInt32BE(int value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddInt32LE(int value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddInt64BE(long value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddInt64LE(long value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddString(string value, System.Text.Encoding encoding) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddStringLatin1(string value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddStringLatin1NullTerminated(string value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddStringUtf16(string value, bool includeBom = true) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddStringUtf16NullTerminated(string value, bool includeBom = true) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddStringUtf8(string value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddStringUtf8NullTerminated(string value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddSyncSafeUInt32(uint value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddUInt16BE(ushort value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddUInt16LE(ushort value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddUInt24BE(uint value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddUInt24LE(uint value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddUInt32BE(uint value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddUInt32LE(uint value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddUInt64BE(ulong value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddUInt64LE(ulong value) { }
        public TagLibSharp2.Core.BinaryDataBuilder AddZeros(int count) { }
        public TagLibSharp2.Core.BinaryDataBuilder Clear() { }
        public void Dispose() { }
        public void EnsureCapacity(int capacity) { }
        public TagLibSharp2.Core.BinaryDataBuilder Insert(int index, System.ReadOnlySpan<byte> data) { }
        public TagLibSharp2.Core.BinaryDataBuilder Insert(int index, TagLibSharp2.Core.BinaryData data) { }
        public TagLibSharp2.Core.BinaryDataBuilder RemoveRange(int index, int count) { }
        public TagLibSharp2.Core.BinaryDataBuilder Reset() { }
        public byte[] ToArray() { }
        public TagLibSharp2.Core.BinaryData ToBinaryData() { }
    }
    public sealed class DefaultFileSystem : TagLibSharp2.Core.IFileSystem
    {
        public static TagLibSharp2.Core.DefaultFileSystem Instance { get; }
        public string CombinePath(string path1, string path2) { }
        public System.IO.Stream Create(string path) { }
        public void Delete(string path) { }
        public bool FileExists(string path) { }
        public string? GetDirectoryName(string path) { }
        public string GetFileName(string path) { }
        public void Move(string sourcePath, string destinationPath) { }
        public System.IO.Stream OpenRead(string path) { }
        public System.IO.Stream OpenReadWrite(string path) { }
        public byte[] ReadAllBytes(string path) { }
        public System.Threading.Tasks.Task<byte[]> ReadAllBytesAsync(string path, System.Threading.CancellationToken cancellationToken = default) { }
        public void WriteAllBytes(string path, System.ReadOnlySpan<byte> data) { }
        public System.Threading.Tasks.Task WriteAllBytesAsync(string path, System.ReadOnlyMemory<byte> data, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public static class ExtendedFloat
    {
        public static byte[] FromDouble(double value) { }
        public static double ToDouble(System.ReadOnlySpan<byte> data) { }
        public static double ToDouble(TagLibSharp2.Core.BinaryData data) { }
        public static double ToDouble(byte[] data) { }
    }
    public static class FileHelper
    {
        public static TagLibSharp2.Core.FileReadResult SafeReadAllBytes(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Core.FileReadResult> SafeReadAllBytesAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
    }
    public readonly struct FileReadResult : System.IEquatable<TagLibSharp2.Core.FileReadResult>
    {
        public System.ReadOnlyMemory<byte>? Data { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Core.FileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Core.FileReadResult Failure(string error) { }
        public static TagLibSharp2.Core.FileReadResult Success(byte[] data) { }
        public static bool operator !=(TagLibSharp2.Core.FileReadResult left, TagLibSharp2.Core.FileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Core.FileReadResult left, TagLibSharp2.Core.FileReadResult right) { }
    }
    public readonly struct FileWriteResult : System.IEquatable<TagLibSharp2.Core.FileWriteResult>
    {
        public int BytesWritten { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Core.FileWriteResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Core.FileWriteResult Failure(string error) { }
        public static TagLibSharp2.Core.FileWriteResult Success(int bytesWritten) { }
        public static bool operator !=(TagLibSharp2.Core.FileWriteResult left, TagLibSharp2.Core.FileWriteResult right) { }
        public static bool operator ==(TagLibSharp2.Core.FileWriteResult left, TagLibSharp2.Core.FileWriteResult right) { }
    }
    public interface IFileSystem
    {
        string CombinePath(string path1, string path2);
        System.IO.Stream Create(string path);
        void Delete(string path);
        bool FileExists(string path);
        string? GetDirectoryName(string path);
        string GetFileName(string path);
        void Move(string sourcePath, string destinationPath);
        System.IO.Stream OpenRead(string path);
        System.IO.Stream OpenReadWrite(string path);
        byte[] ReadAllBytes(string path);
        System.Threading.Tasks.Task<byte[]> ReadAllBytesAsync(string path, System.Threading.CancellationToken cancellationToken = default);
        void WriteAllBytes(string path, System.ReadOnlySpan<byte> data);
        System.Threading.Tasks.Task WriteAllBytesAsync(string path, System.ReadOnlyMemory<byte> data, System.Threading.CancellationToken cancellationToken = default);
    }
    public interface IMediaFile : System.IDisposable
    {
        TagLibSharp2.Core.IMediaProperties? AudioProperties { get; }
        TagLibSharp2.Core.MediaFormat Format { get; }
        TagLibSharp2.Core.ImageProperties? ImageProperties { get; }
        TagLibSharp2.Core.MediaTypes MediaTypes { get; }
        string? SourcePath { get; }
        TagLibSharp2.Core.Tag? Tag { get; }
        TagLibSharp2.Core.VideoProperties? VideoProperties { get; }
    }
    public interface IMediaProperties
    {
        int Bitrate { get; }
        int BitsPerSample { get; }
        int Channels { get; }
        string? Codec { get; }
        System.TimeSpan Duration { get; }
        int SampleRate { get; }
    }
    public interface IPicture
    {
        string Description { get; }
        string MimeType { get; }
        TagLibSharp2.Core.BinaryData PictureData { get; }
        TagLibSharp2.Core.PictureType PictureType { get; }
    }
    public readonly struct ImageProperties : System.IEquatable<TagLibSharp2.Core.ImageProperties>
    {
        public ImageProperties(int Width, int Height, int ColorDepth = 0, string? Format = null) { }
        public int ColorDepth { get; init; }
        public string? Format { get; init; }
        public int Height { get; init; }
        public bool IsValid { get; }
        public int Width { get; init; }
        public static TagLibSharp2.Core.ImageProperties Empty { get; }
        public override string ToString() { }
    }
    public static class MediaFile
    {
        public static TagLibSharp2.Core.MediaFormat DetectFormat(System.ReadOnlySpan<byte> data, string? pathHint = null) { }
        public static TagLibSharp2.Core.MediaFileResult Read(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Core.MediaFileResult> ReadAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static TagLibSharp2.Core.MediaFileResult ReadFromData(System.ReadOnlyMemory<byte> data, string? pathHint = null) { }
    }
    public sealed class MediaFileResult
    {
        public string? Error { get; }
        public object? File { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public T? GetFileAs<T>()
            where T :  class { }
    }
    public enum MediaFormat
    {
        Unknown = 0,
        Flac = 1,
        OggVorbis = 2,
        Opus = 3,
        Mp3 = 4,
        Wav = 5,
        Aiff = 6,
        Mp4 = 7,
        Dsf = 8,
        Dff = 9,
        OggFlac = 10,
        WavPack = 11,
        MonkeysAudio = 12,
        Asf = 13,
        Musepack = 14,
    }
    [System.Flags]
    public enum MediaTypes
    {
        None = 0,
        Audio = 1,
        Video = 2,
        Image = 4,
    }
    public abstract class Picture : TagLibSharp2.Core.IPicture
    {
        protected Picture() { }
        public abstract string Description { get; }
        public abstract string MimeType { get; }
        public abstract TagLibSharp2.Core.BinaryData PictureData { get; }
        public abstract TagLibSharp2.Core.PictureType PictureType { get; }
        public void SaveToFile(string path) { }
        public System.IO.MemoryStream ToStream() { }
        public static string DetectMimeType(System.ReadOnlySpan<byte> data, string? filePath = null) { }
    }
    public enum PictureType : byte
    {
        Other = 0,
        FileIcon = 1,
        OtherFileIcon = 2,
        FrontCover = 3,
        BackCover = 4,
        LeafletPage = 5,
        Media = 6,
        LeadArtist = 7,
        Artist = 8,
        Conductor = 9,
        Band = 10,
        Composer = 11,
        Lyricist = 12,
        RecordingLocation = 13,
        DuringRecording = 14,
        DuringPerformance = 15,
        MovieScreenCapture = 16,
        ColouredFish = 17,
        Illustration = 18,
        BandLogo = 19,
        PublisherLogo = 20,
    }
    public abstract class Tag
    {
        protected Tag() { }
        public virtual string? AcoustIdFingerprint { get; set; }
        public virtual string? AcoustIdId { get; set; }
        public abstract string? Album { get; set; }
        public virtual string? AlbumArtist { get; set; }
        public virtual string? AlbumArtistSort { get; set; }
        public virtual string[] AlbumArtists { get; set; }
        public virtual string[]? AlbumArtistsSort { get; set; }
        public virtual string? AlbumSort { get; set; }
        public virtual string? AmazonId { get; set; }
        public abstract string? Artist { get; set; }
        public virtual string? ArtistSort { get; set; }
        public virtual string? Barcode { get; set; }
        public virtual uint? BeatsPerMinute { get; set; }
        public virtual string? CatalogNumber { get; set; }
        public abstract string? Comment { get; set; }
        public virtual string? Composer { get; set; }
        public virtual string? ComposerSort { get; set; }
        public virtual string[] Composers { get; set; }
        public virtual string[]? ComposersSort { get; set; }
        public virtual string? Conductor { get; set; }
        public virtual string? Copyright { get; set; }
        public virtual string? DateTagged { get; set; }
        public virtual string? Description { get; set; }
        public virtual uint? DiscNumber { get; set; }
        public virtual string? DiscSubtitle { get; set; }
        public virtual string? EncodedBy { get; set; }
        public virtual string? EncoderSettings { get; set; }
        public abstract string? Genre { get; set; }
        public virtual string[] Genres { get; set; }
        public virtual string? Grouping { get; set; }
        public virtual string? InitialKey { get; set; }
        public virtual bool IsCompilation { get; set; }
        public virtual bool IsEmpty { get; }
        public virtual string? Isrc { get; set; }
        public virtual string? Language { get; set; }
        public virtual string? Lyrics { get; set; }
        public virtual string? MediaType { get; set; }
        public virtual string? Mood { get; set; }
        public virtual string? Movement { get; set; }
        public virtual uint? MovementNumber { get; set; }
        public virtual uint? MovementTotal { get; set; }
        public virtual string? MusicBrainzAlbumArtistId { get; set; }
        public virtual string? MusicBrainzArtistId { get; set; }
        public virtual string? MusicBrainzDiscId { get; set; }
        public virtual string? MusicBrainzRecordingId { get; set; }
        public virtual string? MusicBrainzReleaseArtistId { get; set; }
        public virtual string? MusicBrainzReleaseCountry { get; set; }
        public virtual string? MusicBrainzReleaseGroupId { get; set; }
        public virtual string? MusicBrainzReleaseId { get; set; }
        public virtual string? MusicBrainzReleaseStatus { get; set; }
        public virtual string? MusicBrainzReleaseType { get; set; }
        public virtual string? MusicBrainzTrackId { get; set; }
        public virtual string? MusicBrainzWorkId { get; set; }
        public virtual string? OriginalReleaseDate { get; set; }
        public virtual string[] Performers { get; set; }
        public virtual string[]? PerformersRole { get; set; }
        public virtual string[]? PerformersSort { get; set; }
        public virtual TagLibSharp2.Core.IPicture[] Pictures { get; set; }
        public virtual string? PodcastFeedUrl { get; set; }
        public virtual string? Publisher { get; set; }
        public virtual string? R128AlbumGain { get; set; }
        public double? R128AlbumGainDb { get; set; }
        public virtual string? R128TrackGain { get; set; }
        public double? R128TrackGainDb { get; set; }
        public virtual string? Remixer { get; set; }
        public virtual string? ReplayGainAlbumGain { get; set; }
        public virtual string? ReplayGainAlbumPeak { get; set; }
        public virtual string? ReplayGainTrackGain { get; set; }
        public virtual string? ReplayGainTrackPeak { get; set; }
        public virtual string? Subtitle { get; set; }
        public abstract TagLibSharp2.Core.TagTypes TagType { get; }
        public abstract string? Title { get; set; }
        public virtual string? TitleSort { get; set; }
        public virtual uint? TotalDiscs { get; set; }
        public virtual uint? TotalTracks { get; set; }
        public abstract uint? Track { get; set; }
        public virtual string? Work { get; set; }
        public abstract string? Year { get; set; }
        public abstract void Clear();
        public void CopyTo(TagLibSharp2.Core.Tag target, TagLibSharp2.Core.TagCopyOptions options = 63) { }
        public abstract TagLibSharp2.Core.BinaryData Render();
        public virtual TagLibSharp2.Core.ValidationResult Validate() { }
    }
    [System.Flags]
    public enum TagCopyOptions
    {
        None = 0,
        Basic = 1,
        Extended = 2,
        SortOrder = 4,
        ReplayGain = 8,
        MusicBrainz = 16,
        Pictures = 32,
        All = 63,
    }
    public readonly struct TagReadResult<T> : System.IEquatable<TagLibSharp2.Core.TagReadResult<T>>
        where T : TagLibSharp2.Core.Tag
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public bool HasDuplicateTag { get; }
        public bool IsNotFound { get; }
        public bool IsSuccess { get; }
        public T Tag { get; }
        public bool Equals(TagLibSharp2.Core.TagReadResult<T> other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Core.TagReadResult<T> Failure(string error) { }
        public static TagLibSharp2.Core.TagReadResult<T> NotFound() { }
        public static TagLibSharp2.Core.TagReadResult<T> Success(T tag, int bytesConsumed, bool hasDuplicateTag = false) { }
        public static bool operator !=(TagLibSharp2.Core.TagReadResult<T> left, TagLibSharp2.Core.TagReadResult<T> right) { }
        public static bool operator ==(TagLibSharp2.Core.TagReadResult<T> left, TagLibSharp2.Core.TagReadResult<T> right) { }
    }
    [System.Flags]
    public enum TagTypes
    {
        None = 0,
        Id3v1 = 1,
        Id3v2 = 2,
        Ape = 4,
        Xiph = 8,
        Apple = 16,
        Asf = 32,
        RiffInfo = 64,
        Matroska = 128,
        FlacMetadata = 256,
        Xmp = 512,
        AllTags = -1,
    }
    public sealed class ValidationIssue
    {
        public ValidationIssue(string field, TagLibSharp2.Core.ValidationSeverity severity, string message, string? suggestedFix = null) { }
        public string Field { get; }
        public string Message { get; }
        public TagLibSharp2.Core.ValidationSeverity Severity { get; }
        public string? SuggestedFix { get; }
        public override string ToString() { }
    }
    public sealed class ValidationResult
    {
        public ValidationResult() { }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Core.ValidationIssue> AllIssues { get; }
        public int ErrorCount { get; }
        public bool HasErrors { get; }
        public bool HasWarnings { get; }
        public bool IsValid { get; }
        public int WarningCount { get; }
        public void AddError(string field, string message, string? suggestedFix = null) { }
        public void AddInfo(string field, string message) { }
        public void AddIssue(TagLibSharp2.Core.ValidationIssue issue) { }
        public void AddWarning(string field, string message, string? suggestedFix = null) { }
        public System.Collections.Generic.IEnumerable<TagLibSharp2.Core.ValidationIssue> GetIssues(TagLibSharp2.Core.ValidationSeverity severity) { }
    }
    public enum ValidationSeverity
    {
        Info = 0,
        Warning = 1,
        Error = 2,
    }
    public readonly struct VideoProperties : System.IEquatable<TagLibSharp2.Core.VideoProperties>
    {
        public VideoProperties(System.TimeSpan Duration, int Width, int Height, int Bitrate, double FrameRate, string? Codec = null) { }
        public int Bitrate { get; init; }
        public string? Codec { get; init; }
        public System.TimeSpan Duration { get; init; }
        public double FrameRate { get; init; }
        public int Height { get; init; }
        public bool IsValid { get; }
        public int Width { get; init; }
        public static TagLibSharp2.Core.VideoProperties Empty { get; }
        public override string ToString() { }
    }
}
namespace TagLibSharp2.Dff
{
    public sealed class DffAudioProperties : TagLibSharp2.Core.IMediaProperties
    {
        public int Bitrate { get; }
        public int BitsPerSample { get; }
        public int Channels { get; }
        public string? Codec { get; }
        public TagLibSharp2.Dff.DffCompressionType CompressionType { get; }
        public TagLibSharp2.Dsf.DsfSampleRate DsdRate { get; }
        public System.TimeSpan Duration { get; }
        public int SampleRate { get; }
    }
    public enum DffCompressionType
    {
        Dsd = 0,
        Dst = 1,
        Unknown = 2,
    }
    public sealed class DffFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public int BitsPerSample { get; }
        public int Channels { get; }
        public TagLibSharp2.Dff.DffCompressionType CompressionType { get; }
        public TagLibSharp2.Dsf.DsfSampleRate DsdRate { get; }
        public System.TimeSpan Duration { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public int FormatVersionMajor { get; }
        public int FormatVersionMinor { get; }
        public bool HasId3v2Tag { get; }
        public TagLibSharp2.Id3.Id3v2.Id3v2Tag? Id3v2Tag { get; set; }
        public bool IsCompressed { get; }
        public TagLibSharp2.Dff.DffAudioProperties? Properties { get; }
        public ulong SampleCount { get; }
        public int SampleRate { get; }
        public string? SourcePath { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public void Dispose() { }
        public TagLibSharp2.Id3.Id3v2.Id3v2Tag EnsureId3v2Tag() { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Dff.DffFileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Dff.DffFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Dff.DffFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Dff.DffFile? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Dff.DffFile? file) { }
    }
    public readonly struct DffFileReadResult : System.IEquatable<TagLibSharp2.Dff.DffFileReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Dff.DffFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Dff.DffFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Dff.DffFileReadResult Failure(string error) { }
        public static TagLibSharp2.Dff.DffFileReadResult Success(TagLibSharp2.Dff.DffFile file) { }
    }
}
namespace TagLibSharp2.Dsf
{
    public sealed class DsfAudioProperties : TagLibSharp2.Core.IMediaProperties
    {
        public int Bitrate { get; }
        public int BitsPerSample { get; }
        public int BlockSizePerChannel { get; }
        public TagLibSharp2.Dsf.DsfChannelType ChannelType { get; }
        public int Channels { get; }
        public string? Codec { get; }
        public TagLibSharp2.Dsf.DsfSampleRate DsdRate { get; }
        public System.TimeSpan Duration { get; }
        public int SampleRate { get; }
    }
    public enum DsfChannelType
    {
        Mono = 1,
        Stereo = 2,
        ThreeChannels = 3,
        Quad = 4,
        Surround50 = 5,
        Surround51 = 6,
    }
    public sealed class DsfDataChunk
    {
        public const int HeaderSize = 12;
        public ulong AudioDataSize { get; }
        public ulong ChunkSize { get; }
        public static int HeaderSizeValue { get; }
        public static System.ReadOnlySpan<byte> Magic { get; }
        public byte[] RenderHeader() { }
        public static TagLibSharp2.Dsf.DsfDataChunk Create(ulong totalChunkSize) { }
        public static TagLibSharp2.Dsf.DsfDataChunkParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct DsfDataChunkParseResult : System.IEquatable<TagLibSharp2.Dsf.DsfDataChunkParseResult>
    {
        public TagLibSharp2.Dsf.DsfDataChunk? Chunk { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Dsf.DsfDataChunkParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Dsf.DsfDataChunkParseResult Failure(string error) { }
        public static TagLibSharp2.Dsf.DsfDataChunkParseResult Success(TagLibSharp2.Dsf.DsfDataChunk chunk) { }
        public static bool operator !=(TagLibSharp2.Dsf.DsfDataChunkParseResult left, TagLibSharp2.Dsf.DsfDataChunkParseResult right) { }
        public static bool operator ==(TagLibSharp2.Dsf.DsfDataChunkParseResult left, TagLibSharp2.Dsf.DsfDataChunkParseResult right) { }
    }
    public sealed class DsfDsdChunk
    {
        public const int Size = 28;
        public ulong ChunkSize { get; }
        public ulong FileSize { get; }
        public bool HasMetadata { get; }
        public ulong MetadataOffset { get; }
        public static System.ReadOnlySpan<byte> Magic { get; }
        public byte[] Render() { }
        public static TagLibSharp2.Dsf.DsfDsdChunk Create(ulong fileSize, ulong metadataOffset = 0) { }
        public static TagLibSharp2.Dsf.DsfDsdChunkParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct DsfDsdChunkParseResult : System.IEquatable<TagLibSharp2.Dsf.DsfDsdChunkParseResult>
    {
        public TagLibSharp2.Dsf.DsfDsdChunk? Chunk { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Dsf.DsfDsdChunkParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Dsf.DsfDsdChunkParseResult Failure(string error) { }
        public static TagLibSharp2.Dsf.DsfDsdChunkParseResult Success(TagLibSharp2.Dsf.DsfDsdChunk chunk) { }
        public static bool operator !=(TagLibSharp2.Dsf.DsfDsdChunkParseResult left, TagLibSharp2.Dsf.DsfDsdChunkParseResult right) { }
        public static bool operator ==(TagLibSharp2.Dsf.DsfDsdChunkParseResult left, TagLibSharp2.Dsf.DsfDsdChunkParseResult right) { }
    }
    public sealed class DsfFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public int BitsPerSample { get; }
        public int BlockSizePerChannel { get; }
        public TagLibSharp2.Dsf.DsfChannelType ChannelType { get; }
        public int Channels { get; }
        public TagLibSharp2.Dsf.DsfSampleRate DsdRate { get; }
        public System.TimeSpan Duration { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public bool HasId3v2Tag { get; }
        public TagLibSharp2.Id3.Id3v2.Id3v2Tag? Id3v2Tag { get; set; }
        public TagLibSharp2.Dsf.DsfAudioProperties? Properties { get; }
        public ulong SampleCount { get; }
        public int SampleRate { get; }
        public string? SourcePath { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public void Dispose() { }
        public TagLibSharp2.Id3.Id3v2.Id3v2Tag EnsureId3v2Tag() { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Dsf.DsfFileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Dsf.DsfFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Dsf.DsfFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Dsf.DsfFile? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Dsf.DsfFile? file) { }
    }
    public readonly struct DsfFileReadResult : System.IEquatable<TagLibSharp2.Dsf.DsfFileReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Dsf.DsfFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Dsf.DsfFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Dsf.DsfFileReadResult Failure(string error) { }
        public static TagLibSharp2.Dsf.DsfFileReadResult Success(TagLibSharp2.Dsf.DsfFile file) { }
        public static bool operator !=(TagLibSharp2.Dsf.DsfFileReadResult left, TagLibSharp2.Dsf.DsfFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Dsf.DsfFileReadResult left, TagLibSharp2.Dsf.DsfFileReadResult right) { }
    }
    public sealed class DsfFmtChunk
    {
        public const int Size = 52;
        public uint BitsPerSample { get; }
        public uint BlockSizePerChannel { get; }
        public uint ChannelCount { get; }
        public TagLibSharp2.Dsf.DsfChannelType ChannelType { get; }
        public ulong ChunkSize { get; }
        public TagLibSharp2.Dsf.DsfSampleRate DsdRate { get; }
        public System.TimeSpan Duration { get; }
        public uint FormatId { get; }
        public uint FormatVersion { get; }
        public ulong SampleCount { get; }
        public uint SampleRate { get; }
        public static System.ReadOnlySpan<byte> Magic { get; }
        public byte[] Render() { }
        public static TagLibSharp2.Dsf.DsfFmtChunk Create(uint channelCount, uint sampleRate, ulong sampleCount, uint blockSizePerChannel = 4096) { }
        public static TagLibSharp2.Dsf.DsfFmtChunkParseResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct DsfFmtChunkParseResult : System.IEquatable<TagLibSharp2.Dsf.DsfFmtChunkParseResult>
    {
        public TagLibSharp2.Dsf.DsfFmtChunk? Chunk { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Dsf.DsfFmtChunkParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Dsf.DsfFmtChunkParseResult Failure(string error) { }
        public static TagLibSharp2.Dsf.DsfFmtChunkParseResult Success(TagLibSharp2.Dsf.DsfFmtChunk chunk) { }
        public static bool operator !=(TagLibSharp2.Dsf.DsfFmtChunkParseResult left, TagLibSharp2.Dsf.DsfFmtChunkParseResult right) { }
        public static bool operator ==(TagLibSharp2.Dsf.DsfFmtChunkParseResult left, TagLibSharp2.Dsf.DsfFmtChunkParseResult right) { }
    }
    public enum DsfFormatId
    {
        DsdRaw = 0,
    }
    public enum DsfSampleRate
    {
        Unknown = 0,
        DSD64 = 2822400,
        DSD128 = 5644800,
        DSD256 = 11289600,
        DSD512 = 22579200,
        DSD1024 = 45158400,
    }
}
namespace TagLibSharp2.Id3
{
    public static class Id3v1Genre
    {
        public static int Count { get; }
        public static byte GetIndex(string? name) { }
        public static string? GetName(byte index) { }
    }
    public sealed class Id3v1Tag : TagLibSharp2.Core.Tag
    {
        public const int TagSize = 128;
        public Id3v1Tag() { }
        public override string? Album { get; set; }
        public override string? Artist { get; set; }
        public override string? Comment { get; set; }
        public override string? Genre { get; set; }
        public byte GenreIndex { get; set; }
        public bool IsVersion11 { get; }
        public override TagLibSharp2.Core.TagTypes TagType { get; }
        public override string? Title { get; set; }
        public override uint? Track { get; set; }
        public override string? Year { get; set; }
        public override void Clear() { }
        public override TagLibSharp2.Core.BinaryData Render() { }
        public static TagLibSharp2.Core.TagReadResult<TagLibSharp2.Id3.Id3v1Tag> Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Core.TagReadResult<TagLibSharp2.Id3.Id3v1Tag> Read(byte[] data) { }
    }
}
namespace TagLibSharp2.Id3.Id3v2.Frames
{
    public sealed class ChapterFrame
    {
        public ChapterFrame(string elementId, uint startTimeMs, uint endTimeMs) { }
        public string ElementId { get; set; }
        public uint EndByteOffset { get; set; }
        public uint EndTimeMs { get; set; }
        public uint StartByteOffset { get; set; }
        public uint StartTimeMs { get; set; }
        public string? Title { get; set; }
        public static string FrameId { get; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.ChapterFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct ChapterFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.ChapterFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.ChapterFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.ChapterFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.ChapterFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.ChapterFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.ChapterFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.ChapterFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.ChapterFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.ChapterFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.ChapterFrameReadResult right) { }
    }
    public sealed class CommentFrame
    {
        public CommentFrame(string text, string language = "eng", string description = "", TagLibSharp2.Id3.Id3v2.TextEncodingType encoding = 3) { }
        public string Description { get; set; }
        public TagLibSharp2.Id3.Id3v2.TextEncodingType Encoding { get; set; }
        public string Language { get; set; }
        public string Text { get; set; }
        public static string FrameId { get; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.CommentFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct CommentFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.CommentFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.CommentFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.CommentFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.CommentFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.CommentFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.CommentFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.CommentFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.CommentFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.CommentFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.CommentFrameReadResult right) { }
    }
    public sealed class GeneralObjectFrame
    {
        public GeneralObjectFrame(string mimeType, string fileName, string description, TagLibSharp2.Core.BinaryData data, TagLibSharp2.Id3.Id3v2.TextEncodingType encoding = 3) { }
        public TagLibSharp2.Core.BinaryData Data { get; set; }
        public string Description { get; set; }
        public TagLibSharp2.Id3.Id3v2.TextEncodingType Encoding { get; set; }
        public string FileName { get; set; }
        public string MimeType { get; set; }
        public static string FrameId { get; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct GeneralObjectFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrameReadResult right) { }
    }
    public sealed class InvolvedPeopleFrame
    {
        public InvolvedPeopleFrame(TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrameType frameType) { }
        public int Count { get; }
        public TagLibSharp2.Id3.Id3v2.TextEncodingType Encoding { get; set; }
        public string Id { get; }
        [System.Runtime.CompilerServices.TupleElementNames(new string[] {
                "Role",
                "Person"})]
        public System.Collections.Generic.IReadOnlyList<System.ValueTuple<string, string>> Pairs { get; }
        public void Add(string role, string person) { }
        public void Clear() { }
        public System.Collections.Generic.IReadOnlyList<string> GetPeople() { }
        public System.Collections.Generic.IReadOnlyList<string> GetPeopleForRole(string role) { }
        public string? GetPerson(string role) { }
        public System.Collections.Generic.IReadOnlyList<string> GetRoles() { }
        public int Remove(string role) { }
        public bool RemovePair(string role, string person) { }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public void Set(string role, string person) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrameReadResult Read(string frameId, System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct InvolvedPeopleFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrameReadResult right) { }
    }
    public enum InvolvedPeopleFrameType
    {
        InvolvedPeople = 0,
        MusicianCredits = 1,
    }
    public sealed class LyricsFrame
    {
        public LyricsFrame(string text, string language = "eng", string description = "", TagLibSharp2.Id3.Id3v2.TextEncodingType encoding = 3) { }
        public string Description { get; set; }
        public TagLibSharp2.Id3.Id3v2.TextEncodingType Encoding { get; set; }
        public string Language { get; set; }
        public string Text { get; set; }
        public static string FrameId { get; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.LyricsFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct LyricsFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.LyricsFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.LyricsFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.LyricsFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.LyricsFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.LyricsFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.LyricsFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.LyricsFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.LyricsFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.LyricsFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.LyricsFrameReadResult right) { }
    }
    public sealed class PictureFrame : TagLibSharp2.Core.Picture
    {
        public PictureFrame(string mimeType, TagLibSharp2.Core.PictureType pictureType, string description, TagLibSharp2.Core.BinaryData pictureData, TagLibSharp2.Id3.Id3v2.TextEncodingType encoding = 3) { }
        public PictureFrame(string mimeType, TagLibSharp2.Core.PictureType pictureType, string description, byte[] pictureData, TagLibSharp2.Id3.Id3v2.TextEncodingType encoding = 3) { }
        public override string Description { get; }
        public override string MimeType { get; }
        public override TagLibSharp2.Core.BinaryData PictureData { get; }
        public override TagLibSharp2.Core.PictureType PictureType { get; }
        public TagLibSharp2.Id3.Id3v2.TextEncodingType TextEncoding { get; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PictureFrame FromBytes(byte[] imageData, TagLibSharp2.Core.PictureType pictureType = 3, string description = "") { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PictureFrame FromFile(string path, TagLibSharp2.Core.PictureType pictureType = 3, string description = "") { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PictureFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct PictureFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.PictureFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.PictureFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.PictureFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PictureFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PictureFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.PictureFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.PictureFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.PictureFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.PictureFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.PictureFrameReadResult right) { }
    }
    public sealed class PopularimeterFrame
    {
        public PopularimeterFrame(string email, byte rating = 0, ulong playCount = 0) { }
        public string Email { get; set; }
        public ulong PlayCount { get; set; }
        public byte Rating { get; set; }
        public static string FrameId { get; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static int RatingToStars(byte rating) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
        public static byte StarsToRating(int stars) { }
    }
    public readonly struct PopularimeterFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrameReadResult right) { }
    }
    public sealed class PrivateFrame
    {
        public PrivateFrame(string ownerId, TagLibSharp2.Core.BinaryData data) { }
        public TagLibSharp2.Core.BinaryData Data { get; set; }
        public string OwnerId { get; set; }
        public static string FrameId { get; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PrivateFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct PrivateFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.PrivateFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.PrivateFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.PrivateFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PrivateFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.PrivateFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.PrivateFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.PrivateFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.PrivateFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.PrivateFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.PrivateFrameReadResult right) { }
    }
    public sealed class SyncLyricsFrame
    {
        public SyncLyricsFrame() { }
        public TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsType ContentType { get; set; }
        public string Description { get; set; }
        public TagLibSharp2.Id3.Id3v2.TextEncodingType Encoding { get; set; }
        public string Language { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsItem> SyncItems { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.TimestampFormat TimestampFormat { get; set; }
        public static string FrameId { get; }
        public void AddSyncItem(string text, uint timestamp) { }
        public void ClearSyncItems() { }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct SyncLyricsFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrameReadResult right) { }
    }
    public readonly struct SyncLyricsItem : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsItem>
    {
        public SyncLyricsItem(string text, uint timestamp) { }
        public string Text { get; }
        public uint Timestamp { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsItem other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsItem left, TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsItem right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsItem left, TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsItem right) { }
    }
    public enum SyncLyricsType : byte
    {
        Other = 0,
        Lyrics = 1,
        TextTranscription = 2,
        PartNames = 3,
        Events = 4,
        Chords = 5,
        Trivia = 6,
        WebPageUrls = 7,
        ImageUrls = 8,
    }
    public sealed class TableOfContentsFrame
    {
        public TableOfContentsFrame(string elementId) { }
        public System.Collections.Generic.IReadOnlyList<string> ChildElementIds { get; }
        public string ElementId { get; set; }
        public bool IsOrdered { get; set; }
        public bool IsTopLevel { get; set; }
        public string? Title { get; set; }
        public static string FrameId { get; }
        public void AddChildElement(string childId) { }
        public void ClearChildElements() { }
        public bool RemoveChildElement(string childId) { }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct TableOfContentsFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrameReadResult right) { }
    }
    public sealed class TextFrame
    {
        public TextFrame(string id, string text, TagLibSharp2.Id3.Id3v2.TextEncodingType encoding = 3) { }
        public TagLibSharp2.Id3.Id3v2.TextEncodingType Encoding { get; set; }
        public string Id { get; }
        public string Text { get; set; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.TextFrameReadResult Read(string frameId, System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct TextFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.TextFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.TextFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.TextFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.TextFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.TextFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.TextFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.TextFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.TextFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.TextFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.TextFrameReadResult right) { }
    }
    public enum TimestampFormat : byte
    {
        MpegFrames = 1,
        Milliseconds = 2,
    }
    public sealed class UniqueFileIdFrame
    {
        public const string FrameId = "UFID";
        public const string MusicBrainzOwner = "http://musicbrainz.org";
        public UniqueFileIdFrame(string owner, TagLibSharp2.Core.BinaryData identifier) { }
        public UniqueFileIdFrame(string owner, byte[] identifier) { }
        public UniqueFileIdFrame(string owner, string identifierString) { }
        public TagLibSharp2.Core.BinaryData Identifier { get; }
        public string? IdentifierString { get; }
        public string Owner { get; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct UniqueFileIdFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrameReadResult right) { }
    }
    public sealed class UrlFrame
    {
        public UrlFrame(string id, string url) { }
        public string Id { get; }
        public string Url { get; set; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static bool IsUrlFrameId(string frameId) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UrlFrameReadResult Read(string frameId, System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct UrlFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.UrlFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.UrlFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.UrlFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UrlFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UrlFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.UrlFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.UrlFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.UrlFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.UrlFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.UrlFrameReadResult right) { }
    }
    public sealed class UserTextFrame
    {
        public const string FrameId = "TXXX";
        public UserTextFrame(string description, string value, TagLibSharp2.Id3.Id3v2.TextEncodingType encoding = 3) { }
        public string Description { get; set; }
        public TagLibSharp2.Id3.Id3v2.TextEncodingType Encoding { get; set; }
        public string Value { get; set; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UserTextFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct UserTextFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.UserTextFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.UserTextFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.UserTextFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UserTextFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UserTextFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.UserTextFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.UserTextFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.UserTextFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.UserTextFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.UserTextFrameReadResult right) { }
    }
    public sealed class UserUrlFrame
    {
        public UserUrlFrame(string url, string description = "", TagLibSharp2.Id3.Id3v2.TextEncodingType encoding = 3) { }
        public string Description { get; set; }
        public TagLibSharp2.Id3.Id3v2.TextEncodingType Encoding { get; set; }
        public string Url { get; set; }
        public static string FrameId { get; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrameReadResult Read(System.ReadOnlySpan<byte> data, TagLibSharp2.Id3.Id3v2.Id3v2Version version) { }
    }
    public readonly struct UserUrlFrameReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrameReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrame? Frame { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrameReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrameReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrameReadResult Success(TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrame frame, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrameReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrameReadResult left, TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrameReadResult right) { }
    }
}
namespace TagLibSharp2.Id3.Id3v2
{
    public readonly struct Id3v2Header : System.IEquatable<TagLibSharp2.Id3.Id3v2.Id3v2Header>
    {
        public const int FooterSize = 10;
        public const int HeaderSize = 10;
        public Id3v2Header(byte majorVersion, byte minorVersion, TagLibSharp2.Id3.Id3v2.Id3v2HeaderFlags flags, uint tagSize) { }
        public TagLibSharp2.Id3.Id3v2.Id3v2HeaderFlags Flags { get; }
        public bool HasExtendedHeader { get; }
        public bool HasFooter { get; }
        public bool IsExperimental { get; }
        public bool IsUnsynchronized { get; }
        public byte MajorVersion { get; }
        public byte MinorVersion { get; }
        public uint TagSize { get; }
        public uint TotalSize { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Id3v2Header other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public TagLibSharp2.Core.BinaryData RenderFooter() { }
        public static TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult ReadFooter(System.ReadOnlySpan<byte> data) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Id3v2Header left, TagLibSharp2.Id3.Id3v2.Id3v2Header right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Id3v2Header left, TagLibSharp2.Id3.Id3v2.Id3v2Header right) { }
    }
    [System.Flags]
    public enum Id3v2HeaderFlags : byte
    {
        None = 0,
        Unsynchronization = 128,
        ExtendedHeader = 64,
        Experimental = 32,
        Footer = 16,
    }
    public readonly struct Id3v2HeaderReadResult : System.IEquatable<TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Id3.Id3v2.Id3v2Header Header { get; }
        public bool IsNotFound { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult Failure(string error) { }
        public static TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult NotFound() { }
        public static TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult Success(TagLibSharp2.Id3.Id3v2.Id3v2Header header, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult left, TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult right) { }
        public static bool operator ==(TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult left, TagLibSharp2.Id3.Id3v2.Id3v2HeaderReadResult right) { }
    }
    public sealed class Id3v2Tag : TagLibSharp2.Core.Tag
    {
        public Id3v2Tag(TagLibSharp2.Id3.Id3v2.Id3v2Version version = 4) { }
        public override string? AcoustIdFingerprint { get; set; }
        public override string? AcoustIdId { get; set; }
        public override string? Album { get; set; }
        public override string? AlbumArtist { get; set; }
        public override string? AlbumArtistSort { get; set; }
        public override string[] AlbumArtists { get; set; }
        public override string[]? AlbumArtistsSort { get; set; }
        public override string? AlbumSort { get; set; }
        public override string? AmazonId { get; set; }
        public override string? Artist { get; set; }
        public override string? ArtistSort { get; set; }
        public override string? Barcode { get; set; }
        public override uint? BeatsPerMinute { get; set; }
        public override string? CatalogNumber { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.ChapterFrame> ChapterFrames { get; }
        public override string? Comment { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.CommentFrame> Comments { get; }
        public override string? Composer { get; set; }
        public override string? ComposerSort { get; set; }
        public override string[] Composers { get; set; }
        public override string[]? ComposersSort { get; set; }
        public override string? Conductor { get; set; }
        public override string? Copyright { get; set; }
        public TagLibSharp2.Id3.Id3v2.Frames.PictureFrame? CoverArt { get; set; }
        public override string? DateTagged { get; set; }
        public override string? Description { get; set; }
        public override uint? DiscNumber { get; set; }
        public override string? DiscSubtitle { get; set; }
        public override string? EncodedBy { get; set; }
        public override string? EncoderSettings { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.TextFrame> Frames { get; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrame> GeneralObjectFrames { get; }
        public override string? Genre { get; set; }
        public override string[] Genres { get; set; }
        public override string? Grouping { get; set; }
        public bool HasPictures { get; }
        public override string? InitialKey { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrame> InvolvedPeopleFrames { get; }
        public override bool IsCompilation { get; set; }
        public override string? Isrc { get; set; }
        public override string? Language { get; set; }
        public override string? Lyrics { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.LyricsFrame> LyricsFrames { get; }
        public override string? MediaType { get; set; }
        public override string? Mood { get; set; }
        public override string? Movement { get; set; }
        public override uint? MovementNumber { get; set; }
        public override uint? MovementTotal { get; set; }
        public override string? MusicBrainzAlbumArtistId { get; set; }
        public override string? MusicBrainzArtistId { get; set; }
        public override string? MusicBrainzDiscId { get; set; }
        public override string? MusicBrainzRecordingId { get; set; }
        public override string? MusicBrainzReleaseCountry { get; set; }
        public override string? MusicBrainzReleaseGroupId { get; set; }
        public override string? MusicBrainzReleaseId { get; set; }
        public override string? MusicBrainzReleaseStatus { get; set; }
        public override string? MusicBrainzReleaseType { get; set; }
        public override string? MusicBrainzTrackId { get; set; }
        public override string? MusicBrainzWorkId { get; set; }
        public override string? OriginalReleaseDate { get; set; }
        public override string[] Performers { get; set; }
        public override string[]? PerformersRole { get; set; }
        public override string[]? PerformersSort { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.PictureFrame> PictureFrames { get; }
        public override TagLibSharp2.Core.IPicture[] Pictures { get; set; }
        public ulong? PlayCount { get; set; }
        public override string? PodcastFeedUrl { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrame> PopularimeterFrames { get; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.PrivateFrame> PrivateFrames { get; }
        public override string? Publisher { get; set; }
        public override string? R128AlbumGain { get; set; }
        public override string? R128TrackGain { get; set; }
        public byte? Rating { get; set; }
        public override string? Remixer { get; set; }
        public override string? ReplayGainAlbumGain { get; set; }
        public override string? ReplayGainAlbumPeak { get; set; }
        public override string? ReplayGainTrackGain { get; set; }
        public override string? ReplayGainTrackPeak { get; set; }
        public override string? Subtitle { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrame> SyncLyricsFrames { get; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrame> TableOfContentsFrames { get; }
        public override TagLibSharp2.Core.TagTypes TagType { get; }
        public override string? Title { get; set; }
        public override string? TitleSort { get; set; }
        public override uint? TotalDiscs { get; set; }
        public override uint? TotalTracks { get; set; }
        public override uint? Track { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrame> UniqueFileIdFrames { get; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.UrlFrame> UrlFrames { get; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.UserTextFrame> UserTextFrames { get; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Id3.Id3v2.Frames.UserUrlFrame> UserUrlFrames { get; }
        public int Version { get; }
        public override string? Work { get; set; }
        public override string? Year { get; set; }
        public void AddChapter(TagLibSharp2.Id3.Id3v2.Frames.ChapterFrame frame) { }
        public void AddComment(TagLibSharp2.Id3.Id3v2.Frames.CommentFrame comment) { }
        public void AddGeneralObject(TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrame frame) { }
        public void AddInvolvedPeopleFrame(TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrame frame) { }
        public void AddLyrics(TagLibSharp2.Id3.Id3v2.Frames.LyricsFrame lyrics) { }
        public void AddPicture(TagLibSharp2.Id3.Id3v2.Frames.PictureFrame picture) { }
        public void AddPrivateFrame(TagLibSharp2.Id3.Id3v2.Frames.PrivateFrame frame) { }
        public void AddSyncLyrics(TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrame frame) { }
        public void AddTableOfContents(TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrame frame) { }
        public void AddUniqueFileId(TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrame frame) { }
        public void AddUserTextFrame(TagLibSharp2.Id3.Id3v2.Frames.UserTextFrame frame) { }
        public override void Clear() { }
        public TagLibSharp2.Id3.Id3v2.Frames.ChapterFrame? GetChapter(string? elementId = null) { }
        public TagLibSharp2.Id3.Id3v2.Frames.CommentFrame? GetCommentFrame(string? language = null, string? description = null) { }
        public TagLibSharp2.Id3.Id3v2.Frames.GeneralObjectFrame? GetGeneralObject(string? description = null) { }
        public TagLibSharp2.Id3.Id3v2.Frames.InvolvedPeopleFrame? GetInvolvedPeopleFrame(string frameId) { }
        public TagLibSharp2.Id3.Id3v2.Frames.LyricsFrame? GetLyricsFrame(string? language = null, string? description = null) { }
        public TagLibSharp2.Id3.Id3v2.Frames.PictureFrame? GetPicture(TagLibSharp2.Core.PictureType pictureType) { }
        public TagLibSharp2.Id3.Id3v2.Frames.PopularimeterFrame? GetPopularimeter(string email) { }
        public TagLibSharp2.Id3.Id3v2.Frames.PrivateFrame? GetPrivateFrame(string? ownerId = null) { }
        public TagLibSharp2.Id3.Id3v2.Frames.SyncLyricsFrame? GetSyncLyrics(string? language = null, string? description = null) { }
        public TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrame? GetTableOfContents() { }
        public TagLibSharp2.Id3.Id3v2.Frames.TableOfContentsFrame? GetTableOfContentsById(string elementId) { }
        public string? GetTextFrame(string frameId) { }
        public System.Collections.Generic.IReadOnlyList<string> GetTextFrameValues(string frameId) { }
        public TagLibSharp2.Id3.Id3v2.Frames.UniqueFileIdFrame? GetUniqueFileId(string owner) { }
        public string? GetUrl(string frameId) { }
        public string? GetUserText(string description) { }
        public string? GetUserUrl(string description) { }
        public void RemoveAllPictures() { }
        public void RemoveChapters(string? elementId = null) { }
        public void RemoveComments(string? language = null, string? description = null) { }
        public void RemoveGeneralObjects(string? description = null) { }
        public void RemoveInvolvedPeopleFrames(string? frameId = null) { }
        public void RemoveLyrics(string? language = null, string? description = null) { }
        public void RemovePictures(TagLibSharp2.Core.PictureType pictureType) { }
        public void RemovePrivateFrames(string? ownerId = null) { }
        public void RemoveSyncLyrics(string? language = null, string? description = null) { }
        public void RemoveTableOfContents(string? elementId = null) { }
        public void RemoveUniqueFileIds(string? owner = null) { }
        public void RemoveUserTextFrames(string description) { }
        public override TagLibSharp2.Core.BinaryData Render() { }
        public TagLibSharp2.Core.BinaryData Render(int paddingSize, bool withFooter = false) { }
        public void SetPicture(TagLibSharp2.Core.PictureType pictureType, TagLibSharp2.Id3.Id3v2.Frames.PictureFrame? picture) { }
        public void SetPopularimeter(string email, byte rating, ulong playCount = 0) { }
        public void SetTextFrameValues(string frameId, System.Collections.Generic.IEnumerable<string>? values) { }
        public void SetUrl(string frameId, string? url) { }
        public void SetUserText(string description, string? value) { }
        public void SetUserUrl(string description, string? url) { }
        public static TagLibSharp2.Core.TagReadResult<TagLibSharp2.Id3.Id3v2.Id3v2Tag> Read(System.ReadOnlySpan<byte> data) { }
    }
    public enum Id3v2Version
    {
        V22 = 2,
        V23 = 3,
        V24 = 4,
    }
    public enum TextEncodingType : byte
    {
        Latin1 = 0,
        Utf16WithBom = 1,
        Utf16BE = 2,
        Utf8 = 3,
    }
}
namespace TagLibSharp2.Mp4
{
    public enum Mp4AudioCodec
    {
        Unknown = 0,
        Aac = 1,
        Alac = 2,
        Mp3 = 3,
        Ac3 = 4,
        Eac3 = 5,
        Flac = 6,
        Opus = 7,
    }
    public static class Mp4AudioPropertiesParser
    {
        public static TagLibSharp2.Core.AudioProperties Parse(System.ReadOnlySpan<byte> data) { }
    }
    public class Mp4Box
    {
        public const int ExtendedHeaderSize = 16;
        public const int HeaderSize = 8;
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Mp4.Mp4Box> Children { get; }
        public TagLibSharp2.Core.BinaryData Data { get; }
        public bool IsContainer { get; }
        public long TotalSize { get; }
        public string Type { get; }
        public bool UsesExtendedSize { get; }
        public TagLibSharp2.Mp4.Mp4Box? FindChild(string type) { }
        public TagLibSharp2.Mp4.Mp4Box? FindDescendant(params string[] path) { }
        public TagLibSharp2.Mp4.Mp4Box? Navigate(string path) { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public override string ToString() { }
        public static TagLibSharp2.Mp4.Mp4BoxReadResult Parse(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct Mp4BoxReadResult : System.IEquatable<TagLibSharp2.Mp4.Mp4BoxReadResult>
    {
        public Mp4BoxReadResult(TagLibSharp2.Mp4.Mp4Box box, int bytesConsumed) { }
        public TagLibSharp2.Mp4.Mp4Box? Box { get; }
        public int BytesConsumed { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Mp4.Mp4BoxReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Mp4.Mp4BoxReadResult Failure() { }
        public static bool operator !=(TagLibSharp2.Mp4.Mp4BoxReadResult left, TagLibSharp2.Mp4.Mp4BoxReadResult right) { }
        public static bool operator ==(TagLibSharp2.Mp4.Mp4BoxReadResult left, TagLibSharp2.Mp4.Mp4BoxReadResult right) { }
    }
    public sealed class Mp4File : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public string? AcoustIdFingerprint { get; set; }
        public string? AcoustIdId { get; set; }
        public string? Album { get; set; }
        public string? AlbumArtist { get; set; }
        public string? AlbumArtistSort { get; set; }
        public string? AlbumSort { get; set; }
        public string? AmazonId { get; set; }
        public string? Artist { get; set; }
        public string? ArtistSort { get; set; }
        public TagLibSharp2.Mp4.Mp4AudioCodec AudioCodec { get; }
        public string? Barcode { get; set; }
        public string? CatalogNumber { get; set; }
        public string? Comment { get; set; }
        public string? Composer { get; set; }
        public string? ComposerSort { get; set; }
        public string? Conductor { get; set; }
        public string? DateTagged { get; set; }
        public uint? DiscNumber { get; set; }
        public System.TimeSpan Duration { get; }
        public string FileType { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public string? Genre { get; set; }
        public string? InitialKey { get; set; }
        public bool IsGapless { get; set; }
        public string? Isrc { get; set; }
        public string? Language { get; set; }
        public string? MediaType { get; set; }
        public string? Mood { get; set; }
        public string? Movement { get; set; }
        public uint? MovementNumber { get; set; }
        public uint? MovementTotal { get; set; }
        public string? MusicBrainzDiscId { get; set; }
        public string? MusicBrainzRecordingId { get; set; }
        public string? MusicBrainzReleaseCountry { get; set; }
        public string? MusicBrainzReleaseStatus { get; set; }
        public string? MusicBrainzReleaseType { get; set; }
        public string? OriginalReleaseDate { get; set; }
        public TagLibSharp2.Core.IPicture[] Pictures { get; }
        public string? PodcastFeedUrl { get; set; }
        public TagLibSharp2.Core.AudioProperties Properties { get; }
        public string? R128AlbumGain { get; set; }
        public double? R128AlbumGainDb { get; set; }
        public string? R128TrackGain { get; set; }
        public double? R128TrackGainDb { get; set; }
        public string? Remixer { get; set; }
        public string? ReplayGainAlbumGain { get; set; }
        public string? ReplayGainAlbumPeak { get; set; }
        public string? ReplayGainTrackGain { get; set; }
        public string? ReplayGainTrackPeak { get; set; }
        public string? SourcePath { get; }
        public string? Subtitle { get; set; }
        public TagLibSharp2.Mp4.Mp4Tag? Tag { get; set; }
        public string? Title { get; set; }
        public string? TitleSort { get; set; }
        public uint? TotalDiscs { get; set; }
        public uint? TotalTracks { get; set; }
        public uint? Track { get; set; }
        public string? Work { get; set; }
        public string? Year { get; set; }
        public void AddPicture(TagLibSharp2.Core.IPicture picture) { }
        public void ClearAllMetadata() { }
        public void Dispose() { }
        public string? GetFreeformTag(string mean, string name) { }
        public void RemovePictures() { }
        public TagLibSharp2.Core.BinaryData Render(System.ReadOnlySpan<byte> originalData) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public void SetFreeformTag(string mean, string name, string? value) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Mp4.Mp4FileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Mp4.Mp4FileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Mp4.Mp4FileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Mp4.Mp4File? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Mp4.Mp4File? file) { }
    }
    public readonly struct Mp4FileReadResult : System.IEquatable<TagLibSharp2.Mp4.Mp4FileReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Mp4.Mp4File? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Mp4.Mp4FileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Mp4.Mp4FileReadResult Failure(string error) { }
        public static TagLibSharp2.Mp4.Mp4FileReadResult Success(TagLibSharp2.Mp4.Mp4File file, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Mp4.Mp4FileReadResult left, TagLibSharp2.Mp4.Mp4FileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Mp4.Mp4FileReadResult left, TagLibSharp2.Mp4.Mp4FileReadResult right) { }
    }
    public class Mp4FullBox : TagLibSharp2.Mp4.Mp4Box
    {
        public Mp4FullBox(string type, byte version, uint flags, TagLibSharp2.Core.BinaryData contentData, System.Collections.Generic.IReadOnlyList<TagLibSharp2.Mp4.Mp4Box>? children = null, bool usesExtendedSize = false) { }
        public TagLibSharp2.Core.BinaryData ContentData { get; }
        public uint Flags { get; }
        public byte Version { get; }
        public override string ToString() { }
        public static TagLibSharp2.Mp4.Mp4FullBox Parse(string type, TagLibSharp2.Core.BinaryData data, System.Collections.Generic.IReadOnlyList<TagLibSharp2.Mp4.Mp4Box>? children = null, bool usesExtendedSize = false) { }
    }
    public sealed class Mp4Picture : TagLibSharp2.Core.IPicture
    {
        public Mp4Picture(byte[] data, bool isJpeg) { }
        public Mp4Picture(string mimeType, TagLibSharp2.Core.PictureType pictureType, string description, TagLibSharp2.Core.BinaryData pictureData) { }
        public string Description { get; }
        public string MimeType { get; }
        public TagLibSharp2.Core.BinaryData PictureData { get; }
        public TagLibSharp2.Core.PictureType PictureType { get; }
    }
    public sealed class Mp4Tag : TagLibSharp2.Core.Tag
    {
        public Mp4Tag() { }
        public override string? AcoustIdFingerprint { get; set; }
        public override string? AcoustIdId { get; set; }
        public override string? Album { get; set; }
        public override string? AlbumArtist { get; set; }
        public override string? AlbumArtistSort { get; set; }
        public override string? AlbumSort { get; set; }
        public override string? AmazonId { get; set; }
        public override string? Artist { get; set; }
        public override string? ArtistSort { get; set; }
        public override string? Barcode { get; set; }
        public override uint? BeatsPerMinute { get; set; }
        public override string? CatalogNumber { get; set; }
        public override string? Comment { get; set; }
        public override string? Composer { get; set; }
        public override string? ComposerSort { get; set; }
        public override string? Conductor { get; set; }
        public override string? Copyright { get; set; }
        public override string? DateTagged { get; set; }
        public override string? Description { get; set; }
        public override uint? DiscNumber { get; set; }
        public override string? EncodedBy { get; set; }
        public override string? EncoderSettings { get; set; }
        public string? GaplessInfo { get; set; }
        public override string? Genre { get; set; }
        public override string? Grouping { get; set; }
        public override string? InitialKey { get; set; }
        public override bool IsCompilation { get; set; }
        public bool IsGapless { get; set; }
        public override string? Isrc { get; set; }
        public override string? Language { get; set; }
        public override string? Lyrics { get; set; }
        public override string? MediaType { get; set; }
        public override string? Mood { get; set; }
        public override string? Movement { get; set; }
        public override uint? MovementNumber { get; set; }
        public override uint? MovementTotal { get; set; }
        public override string? MusicBrainzAlbumArtistId { get; set; }
        public override string? MusicBrainzArtistId { get; set; }
        public override string? MusicBrainzDiscId { get; set; }
        public override string? MusicBrainzRecordingId { get; set; }
        public override string? MusicBrainzReleaseCountry { get; set; }
        public override string? MusicBrainzReleaseGroupId { get; set; }
        public override string? MusicBrainzReleaseId { get; set; }
        public override string? MusicBrainzReleaseStatus { get; set; }
        public override string? MusicBrainzReleaseType { get; set; }
        public override string? MusicBrainzTrackId { get; set; }
        public override string? MusicBrainzWorkId { get; set; }
        public override string? OriginalReleaseDate { get; set; }
        public override TagLibSharp2.Core.IPicture[] Pictures { get; set; }
        public override string? PodcastFeedUrl { get; set; }
        public override string? Publisher { get; set; }
        public override string? R128AlbumGain { get; set; }
        public override string? R128TrackGain { get; set; }
        public override string? Remixer { get; set; }
        public override string? ReplayGainAlbumGain { get; set; }
        public override string? ReplayGainAlbumPeak { get; set; }
        public override string? ReplayGainTrackGain { get; set; }
        public override string? ReplayGainTrackPeak { get; set; }
        public override string? Subtitle { get; set; }
        public override TagLibSharp2.Core.TagTypes TagType { get; }
        public override string? Title { get; set; }
        public override string? TitleSort { get; set; }
        public override uint? TotalDiscs { get; set; }
        public override uint? TotalTracks { get; set; }
        public override uint? Track { get; set; }
        public override string? Work { get; set; }
        public override string? Year { get; set; }
        public override void Clear() { }
        public override TagLibSharp2.Core.BinaryData Render() { }
    }
}
namespace TagLibSharp2.Mpeg
{
    public enum ChannelMode
    {
        Stereo = 0,
        JointStereo = 1,
        DualChannel = 2,
        Mono = 3,
    }
    public sealed class Mp3File : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public string? Album { get; set; }
        public string? AlbumArtist { get; set; }
        public string? Artist { get; set; }
        public uint? BeatsPerMinute { get; set; }
        public string? Comment { get; set; }
        public string? Composer { get; set; }
        public uint? DiscNumber { get; set; }
        public System.TimeSpan? Duration { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public string? Genre { get; set; }
        public bool HasId3v1Tag { get; }
        public bool HasId3v2Tag { get; }
        public TagLibSharp2.Id3.Id3v1Tag? Id3v1Tag { get; set; }
        public int Id3v2Size { get; }
        public TagLibSharp2.Id3.Id3v2.Id3v2Tag? Id3v2Tag { get; set; }
        public string? MusicBrainzAlbumArtistId { get; set; }
        public string? MusicBrainzArtistId { get; set; }
        public string? MusicBrainzReleaseGroupId { get; set; }
        public string? MusicBrainzReleaseId { get; set; }
        public string? MusicBrainzTrackId { get; set; }
        public TagLibSharp2.Mpeg.MpegAudioProperties? Properties { get; }
        public string? ReplayGainAlbumGain { get; set; }
        public string? ReplayGainAlbumPeak { get; set; }
        public string? ReplayGainTrackGain { get; set; }
        public string? ReplayGainTrackPeak { get; set; }
        public string? SourcePath { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public string? Title { get; set; }
        public uint? Track { get; set; }
        public string? Year { get; set; }
        public void Dispose() { }
        public TagLibSharp2.Core.BinaryData Render(System.ReadOnlySpan<byte> originalData) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Mpeg.Mp3FileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Mpeg.Mp3FileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Mpeg.Mp3FileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Mpeg.Mp3File? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Mpeg.Mp3File? file) { }
    }
    public readonly struct Mp3FileReadResult : System.IEquatable<TagLibSharp2.Mpeg.Mp3FileReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Mpeg.Mp3File? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Mpeg.Mp3FileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Mpeg.Mp3FileReadResult Failure(string error) { }
        public static TagLibSharp2.Mpeg.Mp3FileReadResult Success(TagLibSharp2.Mpeg.Mp3File file) { }
        public static bool operator !=(TagLibSharp2.Mpeg.Mp3FileReadResult left, TagLibSharp2.Mpeg.Mp3FileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Mpeg.Mp3FileReadResult left, TagLibSharp2.Mpeg.Mp3FileReadResult right) { }
    }
    public sealed class MpegAudioProperties : TagLibSharp2.Core.IMediaProperties
    {
        public int Bitrate { get; }
        public int BitsPerSample { get; }
        public int Channels { get; }
        public string Codec { get; }
        public System.TimeSpan Duration { get; }
        public uint? FrameCount { get; }
        public bool IsVbr { get; }
        public TagLibSharp2.Mpeg.MpegLayer Layer { get; }
        public int SampleRate { get; }
        public TagLibSharp2.Mpeg.MpegVersion Version { get; }
        public static bool TryParse(TagLibSharp2.Core.BinaryData data, int audioOffset, out TagLibSharp2.Mpeg.MpegAudioProperties? properties) { }
    }
    public sealed class MpegFrame
    {
        public const int HeaderSize = 4;
        public const int VbriHeaderOffset = 36;
        public int Bitrate { get; }
        public TagLibSharp2.Mpeg.ChannelMode ChannelMode { get; }
        public int FrameSize { get; }
        public bool HasCrc { get; }
        public bool HasPadding { get; }
        public TagLibSharp2.Mpeg.MpegLayer Layer { get; }
        public int SampleRate { get; }
        public int SamplesPerFrame { get; }
        public TagLibSharp2.Mpeg.MpegVersion Version { get; }
        public int XingHeaderOffset { get; }
        public static bool TryParse(TagLibSharp2.Core.BinaryData data, int offset, out TagLibSharp2.Mpeg.MpegFrame? frame) { }
    }
    public enum MpegLayer
    {
        Invalid = 0,
        Layer3 = 1,
        Layer2 = 2,
        Layer1 = 3,
    }
    public enum MpegVersion
    {
        Version25 = 0,
        Invalid = 1,
        Version2 = 2,
        Version1 = 3,
    }
    public sealed class VbriHeader
    {
        public const int MinHeaderSize = 26;
        public uint ByteCount { get; }
        public int Delay { get; }
        public uint FrameCount { get; }
        public int Quality { get; }
        public int Version { get; }
        public static bool TryParse(TagLibSharp2.Core.BinaryData data, int offset, out TagLibSharp2.Mpeg.VbriHeader? header) { }
    }
    public sealed class XingHeader
    {
        public uint? ByteCount { get; }
        public uint? FrameCount { get; }
        public bool HasToc { get; }
        public bool IsVbr { get; }
        public uint? Quality { get; }
        public static bool TryParse(TagLibSharp2.Core.BinaryData data, int offset, out TagLibSharp2.Mpeg.XingHeader? header) { }
    }
}
namespace TagLibSharp2.Musepack
{
    public sealed class MusepackFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public TagLibSharp2.Ape.ApeTag? ApeTag { get; }
        public int Channels { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public uint FrameCount { get; }
        public TagLibSharp2.Core.AudioProperties Properties { get; }
        public int SampleRate { get; }
        public string? SourcePath { get; }
        public int StreamVersion { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public ulong TotalSamples { get; }
        public void Dispose() { }
        public TagLibSharp2.Ape.ApeTag EnsureApeTag() { }
        public void RemoveApeTag() { }
        public byte[] Render(System.ReadOnlySpan<byte> originalData) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Musepack.MusepackFileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Musepack.MusepackFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Musepack.MusepackFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Musepack.MusepackFile? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Musepack.MusepackFile? file) { }
    }
    public readonly struct MusepackFileReadResult : System.IEquatable<TagLibSharp2.Musepack.MusepackFileReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Musepack.MusepackFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Musepack.MusepackFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Musepack.MusepackFileReadResult Failure(string error) { }
        public static TagLibSharp2.Musepack.MusepackFileReadResult Success(TagLibSharp2.Musepack.MusepackFile file) { }
        public static bool operator !=(TagLibSharp2.Musepack.MusepackFileReadResult left, TagLibSharp2.Musepack.MusepackFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Musepack.MusepackFileReadResult left, TagLibSharp2.Musepack.MusepackFileReadResult right) { }
    }
}
namespace TagLibSharp2.Ogg
{
    public static class OggCrc
    {
        public static uint Calculate(System.ReadOnlySpan<byte> data) { }
        public static uint Calculate(byte[] data) { }
        public static bool Validate(System.ReadOnlySpan<byte> data) { }
    }
    public sealed class OggFlacFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public int BitsPerSample { get; }
        public int Channels { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public TagLibSharp2.Core.AudioProperties Properties { get; }
        public int SampleRate { get; }
        public string? SourcePath { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public ulong TotalSamples { get; }
        public TagLibSharp2.Xiph.VorbisComment? VorbisComment { get; }
        public void Dispose() { }
        public TagLibSharp2.Xiph.VorbisComment EnsureVorbisComment() { }
        public void RemoveVorbisComment() { }
        public byte[] Render(System.ReadOnlySpan<byte> originalData) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Ogg.OggFlacFileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Ogg.OggFlacFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Ogg.OggFlacFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Ogg.OggFlacFile? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Ogg.OggFlacFile? file) { }
    }
    public readonly struct OggFlacFileReadResult : System.IEquatable<TagLibSharp2.Ogg.OggFlacFileReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Ogg.OggFlacFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Ogg.OggFlacFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Ogg.OggFlacFileReadResult Failure(string error) { }
        public static TagLibSharp2.Ogg.OggFlacFileReadResult Success(TagLibSharp2.Ogg.OggFlacFile file) { }
        public static bool operator !=(TagLibSharp2.Ogg.OggFlacFileReadResult left, TagLibSharp2.Ogg.OggFlacFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Ogg.OggFlacFileReadResult left, TagLibSharp2.Ogg.OggFlacFileReadResult right) { }
    }
    public sealed class OggOpusFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public string? Album { get; set; }
        public string? Artist { get; set; }
        public string? Comment { get; set; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public string? Genre { get; set; }
        public uint InputSampleRate { get; }
        public short OutputGain { get; }
        public double OutputGainDb { get; }
        public ushort PreSkip { get; }
        public TagLibSharp2.Core.AudioProperties Properties { get; }
        public string? SourcePath { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public string? Title { get; set; }
        public uint? Track { get; set; }
        public TagLibSharp2.Xiph.VorbisComment? VorbisComment { get; set; }
        public string? Year { get; set; }
        public void Dispose() { }
        public TagLibSharp2.Core.BinaryData Render(System.ReadOnlySpan<byte> originalData) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Ogg.OggOpusFileReadResult Read(System.ReadOnlySpan<byte> data, bool validateCrc = false) { }
        public static TagLibSharp2.Ogg.OggOpusFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, bool validateCrc = false) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Ogg.OggOpusFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, bool validateCrc = false, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Ogg.OggOpusFile? file, bool validateCrc = false) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Ogg.OggOpusFile? file, bool validateCrc = false) { }
    }
    public readonly struct OggOpusFileReadResult : System.IEquatable<TagLibSharp2.Ogg.OggOpusFileReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Ogg.OggOpusFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Ogg.OggOpusFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Ogg.OggOpusFileReadResult Failure(string error) { }
        public static TagLibSharp2.Ogg.OggOpusFileReadResult Success(TagLibSharp2.Ogg.OggOpusFile file, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Ogg.OggOpusFileReadResult left, TagLibSharp2.Ogg.OggOpusFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Ogg.OggOpusFileReadResult left, TagLibSharp2.Ogg.OggOpusFileReadResult right) { }
    }
    public readonly struct OggPage : System.IEquatable<TagLibSharp2.Ogg.OggPage>
    {
        public const int MinHeaderSize = 27;
        public OggPage(byte version, TagLibSharp2.Ogg.OggPageFlags flags, ulong granulePosition, uint serialNumber, uint sequenceNumber, uint checksum, System.ReadOnlyMemory<byte> data) { }
        public uint Checksum { get; }
        public System.ReadOnlyMemory<byte> Data { get; }
        public TagLibSharp2.Ogg.OggPageFlags Flags { get; }
        public ulong GranulePosition { get; }
        public bool IsBeginOfStream { get; }
        public bool IsContinuation { get; }
        public bool IsEndOfStream { get; }
        public uint SequenceNumber { get; }
        public uint SerialNumber { get; }
        public byte Version { get; }
        public bool Equals(TagLibSharp2.Ogg.OggPage other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Ogg.OggPageReadResult Read(System.ReadOnlySpan<byte> data, bool validateCrc = false) { }
        public static bool operator !=(TagLibSharp2.Ogg.OggPage left, TagLibSharp2.Ogg.OggPage right) { }
        public static bool operator ==(TagLibSharp2.Ogg.OggPage left, TagLibSharp2.Ogg.OggPage right) { }
    }
    [System.Flags]
    public enum OggPageFlags : byte
    {
        None = 0,
        Continuation = 1,
        BeginOfStream = 2,
        EndOfStream = 4,
    }
    public readonly struct OggPageReadResult : System.IEquatable<TagLibSharp2.Ogg.OggPageReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Ogg.OggPage Page { get; }
        public bool Equals(TagLibSharp2.Ogg.OggPageReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Ogg.OggPageReadResult Failure(string error) { }
        public static TagLibSharp2.Ogg.OggPageReadResult Success(TagLibSharp2.Ogg.OggPage page, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Ogg.OggPageReadResult left, TagLibSharp2.Ogg.OggPageReadResult right) { }
        public static bool operator ==(TagLibSharp2.Ogg.OggPageReadResult left, TagLibSharp2.Ogg.OggPageReadResult right) { }
    }
    public sealed class OggVorbisFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public string? Album { get; set; }
        public string? Artist { get; set; }
        public string? Comment { get; set; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public string? Genre { get; set; }
        public TagLibSharp2.Core.AudioProperties Properties { get; }
        public string? SourcePath { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public string? Title { get; set; }
        public uint? Track { get; set; }
        public TagLibSharp2.Xiph.VorbisComment? VorbisComment { get; set; }
        public string? Year { get; set; }
        public void Dispose() { }
        public TagLibSharp2.Core.BinaryData Render(System.ReadOnlySpan<byte> originalData) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Ogg.OggVorbisFileReadResult Read(System.ReadOnlySpan<byte> data, bool validateCrc = false) { }
        public static TagLibSharp2.Ogg.OggVorbisFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, bool validateCrc = false) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Ogg.OggVorbisFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, bool validateCrc = false, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Ogg.OggVorbisFile? file, bool validateCrc = false) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Ogg.OggVorbisFile? file, bool validateCrc = false) { }
    }
    public readonly struct OggVorbisFileReadResult : System.IEquatable<TagLibSharp2.Ogg.OggVorbisFileReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Ogg.OggVorbisFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Ogg.OggVorbisFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Ogg.OggVorbisFileReadResult Failure(string error) { }
        public static TagLibSharp2.Ogg.OggVorbisFileReadResult Success(TagLibSharp2.Ogg.OggVorbisFile file, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Ogg.OggVorbisFileReadResult left, TagLibSharp2.Ogg.OggVorbisFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Ogg.OggVorbisFileReadResult left, TagLibSharp2.Ogg.OggVorbisFileReadResult right) { }
    }
}
namespace TagLibSharp2.Riff
{
    public class BextTag
    {
        public const string ChunkId = "bext";
        public const int MinimumSize = 602;
        public BextTag() { }
        public string? CodingHistory { get; set; }
        public string? Description { get; set; }
        public bool IsEmpty { get; }
        public string? OriginationDate { get; set; }
        public string? OriginationTime { get; set; }
        public string? Originator { get; set; }
        public string? OriginatorReference { get; set; }
        public ulong TimeReference { get; set; }
        public byte[]? Umid { get; set; }
        public ushort Version { get; set; }
        public TagLibSharp2.Core.BinaryData Render() { }
        public static TagLibSharp2.Riff.BextTag? Parse(TagLibSharp2.Core.BinaryData data) { }
    }
    public readonly struct RiffChunk : System.IEquatable<TagLibSharp2.Riff.RiffChunk>
    {
        public const int HeaderSize = 8;
        public RiffChunk(string fourCC, TagLibSharp2.Core.BinaryData data) { }
        public TagLibSharp2.Core.BinaryData Data { get; }
        public uint DataSize { get; }
        public string FourCC { get; }
        public bool IsValid { get; }
        public int TotalSize { get; }
        public bool Equals(TagLibSharp2.Riff.RiffChunk other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public override string ToString() { }
        public static bool TryParse(TagLibSharp2.Core.BinaryData data, int offset, out TagLibSharp2.Riff.RiffChunk chunk) { }
        public static bool operator !=(TagLibSharp2.Riff.RiffChunk left, TagLibSharp2.Riff.RiffChunk right) { }
        public static bool operator ==(TagLibSharp2.Riff.RiffChunk left, TagLibSharp2.Riff.RiffChunk right) { }
    }
    public class RiffFile
    {
        public const int HeaderSize = 12;
        public static readonly TagLibSharp2.Core.BinaryData RiffMagic;
        public static readonly TagLibSharp2.Core.BinaryData WaveType;
        public RiffFile() { }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Riff.RiffChunk> AllChunks { get; }
        public uint FileSize { get; }
        public string FormType { get; }
        public bool IsValid { get; }
        public TagLibSharp2.Riff.RiffChunk? GetChunk(string fourCC) { }
        public System.Collections.Generic.IEnumerable<TagLibSharp2.Riff.RiffChunk> GetChunks(string fourCC) { }
        public bool RemoveChunks(string fourCC) { }
        public TagLibSharp2.Core.BinaryData Render(string? formType = null) { }
        public void SetChunk(TagLibSharp2.Riff.RiffChunk chunk) { }
        public static bool TryParse(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Riff.RiffFile file) { }
    }
    public class RiffInfoTag : TagLibSharp2.Core.Tag
    {
        public const string IART = "IART";
        public const string ICMT = "ICMT";
        public const string ICOP = "ICOP";
        public const string ICRD = "ICRD";
        public const string IENG = "IENG";
        public const string IGNR = "IGNR";
        public const string IKEY = "IKEY";
        public const string INAM = "INAM";
        public const string IPRD = "IPRD";
        public const string ISBJ = "ISBJ";
        public const string ISFT = "ISFT";
        public const string ISRC = "ISRC";
        public const string ITCH = "ITCH";
        public const string ITRK = "ITRK";
        public RiffInfoTag() { }
        public override string? Album { get; set; }
        public override string? Artist { get; set; }
        public override string? Comment { get; set; }
        public override string? Copyright { get; set; }
        public System.Collections.Generic.IEnumerable<string> FieldIds { get; }
        public override string? Genre { get; set; }
        public override string[] Genres { get; set; }
        public override bool IsEmpty { get; }
        public override string[] Performers { get; set; }
        public string? Software { get; set; }
        public override TagLibSharp2.Core.TagTypes TagType { get; }
        public override string? Title { get; set; }
        public override uint? Track { get; set; }
        public override string? Year { get; set; }
        public override void Clear() { }
        public string? GetField(string fourCC) { }
        public override TagLibSharp2.Core.BinaryData Render() { }
        public void SetField(string fourCC, string? value) { }
        public static TagLibSharp2.Riff.RiffInfoTag? Parse(TagLibSharp2.Core.BinaryData data) { }
    }
    public static class WavAudioPropertiesParser
    {
        public const ushort FormatExtensible = 65534;
        public const ushort FormatIeeeFloat = 3;
        public const ushort FormatPcm = 1;
        public static string GetFormatDescription(ushort formatCode) { }
        public static TagLibSharp2.Core.AudioProperties? Parse(TagLibSharp2.Core.BinaryData fmtData, long dataChunkSize = -1) { }
        public static TagLibSharp2.Riff.WavExtendedProperties? ParseExtended(TagLibSharp2.Core.BinaryData fmtData) { }
    }
    public static class WavChannelMask
    {
        public const uint BackCenter = 256u;
        public const uint BackLeft = 16u;
        public const uint BackRight = 32u;
        public const uint FrontCenter = 4u;
        public const uint FrontLeft = 1u;
        public const uint FrontLeftOfCenter = 64u;
        public const uint FrontRight = 2u;
        public const uint FrontRightOfCenter = 128u;
        public const uint LowFrequency = 8u;
        public const uint SideLeft = 512u;
        public const uint SideRight = 1024u;
        public const uint TopBackCenter = 65536u;
        public const uint TopBackLeft = 32768u;
        public const uint TopBackRight = 131072u;
        public const uint TopCenter = 2048u;
        public const uint TopFrontCenter = 8192u;
        public const uint TopFrontLeft = 4096u;
        public const uint TopFrontRight = 16384u;
    }
    public readonly struct WavExtendedProperties : System.IEquatable<TagLibSharp2.Riff.WavExtendedProperties>
    {
        public WavExtendedProperties(int channels, int sampleRate, int bitsPerSample, int validBitsPerSample, uint channelMask, TagLibSharp2.Riff.WavSubFormat subFormat) { }
        public int BitsPerSample { get; }
        public uint ChannelMask { get; }
        public int Channels { get; }
        public int SampleRate { get; }
        public TagLibSharp2.Riff.WavSubFormat SubFormat { get; }
        public int ValidBitsPerSample { get; }
        public bool Equals(TagLibSharp2.Riff.WavExtendedProperties other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static bool operator !=(TagLibSharp2.Riff.WavExtendedProperties left, TagLibSharp2.Riff.WavExtendedProperties right) { }
        public static bool operator ==(TagLibSharp2.Riff.WavExtendedProperties left, TagLibSharp2.Riff.WavExtendedProperties right) { }
    }
    public sealed class WavFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public const string BextChunkId = "bext";
        public const string DataChunkId = "data";
        public const string FmtChunkId = "fmt ";
        public const string Id3ChunkId = "id3 ";
        public const string ListChunkId = "LIST";
        public string? Album { get; }
        public TagLibSharp2.Riff.BextTag? BextTag { get; set; }
        public string? Comment { get; }
        public TagLibSharp2.Id3.Id3v2.Frames.PictureFrame? CoverArt { get; }
        public TagLibSharp2.Riff.WavExtendedProperties? ExtendedProperties { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public string[]? Genres { get; }
        public bool HasPictures { get; }
        public TagLibSharp2.Id3.Id3v2.Id3v2Tag? Id3v2Tag { get; set; }
        public TagLibSharp2.Riff.RiffInfoTag? InfoTag { get; set; }
        public bool IsValid { get; }
        public string[]? Performers { get; }
        public TagLibSharp2.Core.IPicture[] Pictures { get; }
        public TagLibSharp2.Core.AudioProperties Properties { get; }
        public string? SourcePath { get; }
        public string? Title { get; }
        public uint? Track { get; }
        public string? Year { get; }
        public void Dispose() { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Riff.WavFileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Riff.WavFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Riff.WavFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Riff.WavFile? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Riff.WavFile? file) { }
    }
    public readonly struct WavFileReadResult : System.IEquatable<TagLibSharp2.Riff.WavFileReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Riff.WavFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Riff.WavFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Riff.WavFileReadResult Failure(string error) { }
        public static TagLibSharp2.Riff.WavFileReadResult Success(TagLibSharp2.Riff.WavFile file) { }
        public static bool operator !=(TagLibSharp2.Riff.WavFileReadResult left, TagLibSharp2.Riff.WavFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Riff.WavFileReadResult left, TagLibSharp2.Riff.WavFileReadResult right) { }
    }
    public enum WavSubFormat
    {
        Unknown = 0,
        Pcm = 1,
        IeeeFloat = 3,
        ALaw = 6,
        MuLaw = 7,
    }
}
namespace TagLibSharp2.WavPack
{
    public sealed class WavPackFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public TagLibSharp2.Ape.ApeTag? ApeTag { get; }
        public int BitsPerSample { get; }
        public uint BlockSize { get; }
        public int Channels { get; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public TagLibSharp2.Core.AudioProperties Properties { get; }
        public int SampleRate { get; }
        public string? SourcePath { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public uint TotalSamples { get; }
        public int Version { get; }
        public void Dispose() { }
        public TagLibSharp2.Ape.ApeTag EnsureApeTag() { }
        public void RemoveApeTag() { }
        public byte[] Render(System.ReadOnlySpan<byte> originalData) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.WavPack.WavPackFileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.WavPack.WavPackFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.WavPack.WavPackFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.WavPack.WavPackFile? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.WavPack.WavPackFile? file) { }
    }
    public readonly struct WavPackFileReadResult : System.IEquatable<TagLibSharp2.WavPack.WavPackFileReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.WavPack.WavPackFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.WavPack.WavPackFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.WavPack.WavPackFileReadResult Failure(string error) { }
        public static TagLibSharp2.WavPack.WavPackFileReadResult Success(TagLibSharp2.WavPack.WavPackFile file) { }
        public static bool operator !=(TagLibSharp2.WavPack.WavPackFileReadResult left, TagLibSharp2.WavPack.WavPackFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.WavPack.WavPackFileReadResult left, TagLibSharp2.WavPack.WavPackFileReadResult right) { }
    }
}
namespace TagLibSharp2.Xiph
{
    public enum FlacBlockType : byte
    {
        StreamInfo = 0,
        Padding = 1,
        Application = 2,
        SeekTable = 3,
        VorbisComment = 4,
        CueSheet = 5,
        Picture = 6,
    }
    public sealed class FlacCueSheet
    {
        public FlacCueSheet() { }
        public bool IsCompactDisc { get; set; }
        public ulong LeadInSamples { get; set; }
        public string MediaCatalogNumber { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Xiph.FlacCueSheetTrack> Tracks { get; }
        public void AddTrack(TagLibSharp2.Xiph.FlacCueSheetTrack track) { }
        public void ClearTracks() { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public static TagLibSharp2.Xiph.FlacCueSheetReadResult Read(System.ReadOnlySpan<byte> data) { }
    }
    public sealed class FlacCueSheetIndex
    {
        public FlacCueSheetIndex(byte indexNumber, ulong offset) { }
        public byte IndexNumber { get; set; }
        public ulong Offset { get; set; }
    }
    public readonly struct FlacCueSheetReadResult : System.IEquatable<TagLibSharp2.Xiph.FlacCueSheetReadResult>
    {
        public int BytesConsumed { get; }
        public TagLibSharp2.Xiph.FlacCueSheet? CueSheet { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Xiph.FlacCueSheetReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Xiph.FlacCueSheetReadResult Failure(string error) { }
        public static TagLibSharp2.Xiph.FlacCueSheetReadResult Success(TagLibSharp2.Xiph.FlacCueSheet cueSheet, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Xiph.FlacCueSheetReadResult left, TagLibSharp2.Xiph.FlacCueSheetReadResult right) { }
        public static bool operator ==(TagLibSharp2.Xiph.FlacCueSheetReadResult left, TagLibSharp2.Xiph.FlacCueSheetReadResult right) { }
    }
    public sealed class FlacCueSheetTrack
    {
        public FlacCueSheetTrack(byte trackNumber, ulong offset) { }
        public bool HasPreEmphasis { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Xiph.FlacCueSheetIndex> Indices { get; }
        public bool IsAudio { get; set; }
        public string Isrc { get; set; }
        public ulong Offset { get; set; }
        public byte TrackNumber { get; set; }
        public void AddIndex(TagLibSharp2.Xiph.FlacCueSheetIndex index) { }
        public void ClearIndices() { }
    }
    public sealed class FlacFile : System.IDisposable, TagLibSharp2.Core.IMediaFile
    {
        public string? Album { get; set; }
        public string? Artist { get; set; }
        public System.ReadOnlySpan<byte> AudioMd5Signature { get; }
        public string? AudioMd5SignatureHex { get; }
        public string? Comment { get; set; }
        public TagLibSharp2.Xiph.FlacCueSheet? CueSheet { get; set; }
        public TagLibSharp2.Core.MediaFormat Format { get; }
        public string? Genre { get; set; }
        public bool HasAudioMd5Signature { get; }
        public int MetadataSize { get; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Xiph.FlacPicture> Pictures { get; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Xiph.FlacPreservedBlock> PreservedBlocks { get; }
        public TagLibSharp2.Core.AudioProperties Properties { get; }
        public string? SourcePath { get; }
        public TagLibSharp2.Core.BinaryData StreamInfoData { get; }
        public TagLibSharp2.Core.Tag? Tag { get; }
        public string? Title { get; set; }
        public uint? Track { get; set; }
        public TagLibSharp2.Xiph.VorbisComment? VorbisComment { get; set; }
        public string? Year { get; set; }
        public void AddPicture(TagLibSharp2.Xiph.FlacPicture picture) { }
        public void Dispose() { }
        public void RemoveAllPictures() { }
        public void RemovePictures(TagLibSharp2.Core.PictureType pictureType) { }
        public TagLibSharp2.Core.BinaryData Render(System.ReadOnlySpan<byte> originalData) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public TagLibSharp2.Core.FileWriteResult SaveToFile(string path, System.ReadOnlySpan<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public System.Threading.Tasks.Task<TagLibSharp2.Core.FileWriteResult> SaveToFileAsync(string path, System.ReadOnlyMemory<byte> originalData, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool IsValidFormat(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Xiph.FlacFileReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static TagLibSharp2.Xiph.FlacFileReadResult ReadFromFile(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null) { }
        public static System.Threading.Tasks.Task<TagLibSharp2.Xiph.FlacFileReadResult> ReadFromFileAsync(string path, TagLibSharp2.Core.IFileSystem? fileSystem = null, System.Threading.CancellationToken cancellationToken = default) { }
        public static bool TryRead(System.ReadOnlySpan<byte> data, out TagLibSharp2.Xiph.FlacFile? file) { }
        public static bool TryRead(TagLibSharp2.Core.BinaryData data, out TagLibSharp2.Xiph.FlacFile? file) { }
    }
    public readonly struct FlacFileReadResult : System.IEquatable<TagLibSharp2.Xiph.FlacFileReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public TagLibSharp2.Xiph.FlacFile? File { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Xiph.FlacFileReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Xiph.FlacFileReadResult Failure(string error) { }
        public static TagLibSharp2.Xiph.FlacFileReadResult Success(TagLibSharp2.Xiph.FlacFile file, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Xiph.FlacFileReadResult left, TagLibSharp2.Xiph.FlacFileReadResult right) { }
        public static bool operator ==(TagLibSharp2.Xiph.FlacFileReadResult left, TagLibSharp2.Xiph.FlacFileReadResult right) { }
    }
    public readonly struct FlacMetadataBlockHeader : System.IEquatable<TagLibSharp2.Xiph.FlacMetadataBlockHeader>
    {
        public const int HeaderSize = 4;
        public FlacMetadataBlockHeader(bool isLast, TagLibSharp2.Xiph.FlacBlockType blockType, int dataLength) { }
        public TagLibSharp2.Xiph.FlacBlockType BlockType { get; }
        public int DataLength { get; }
        public bool IsLast { get; }
        public bool Equals(TagLibSharp2.Xiph.FlacMetadataBlockHeader other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public TagLibSharp2.Core.BinaryData Render() { }
        public static TagLibSharp2.Xiph.FlacMetadataBlockHeaderReadResult Read(System.ReadOnlySpan<byte> data) { }
        public static bool operator !=(TagLibSharp2.Xiph.FlacMetadataBlockHeader left, TagLibSharp2.Xiph.FlacMetadataBlockHeader right) { }
        public static bool operator ==(TagLibSharp2.Xiph.FlacMetadataBlockHeader left, TagLibSharp2.Xiph.FlacMetadataBlockHeader right) { }
    }
    public readonly struct FlacMetadataBlockHeaderReadResult : System.IEquatable<TagLibSharp2.Xiph.FlacMetadataBlockHeaderReadResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Xiph.FlacMetadataBlockHeader Header { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Xiph.FlacMetadataBlockHeaderReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Xiph.FlacMetadataBlockHeaderReadResult Failure(string error) { }
        public static TagLibSharp2.Xiph.FlacMetadataBlockHeaderReadResult Success(TagLibSharp2.Xiph.FlacMetadataBlockHeader header) { }
        public static bool operator !=(TagLibSharp2.Xiph.FlacMetadataBlockHeaderReadResult left, TagLibSharp2.Xiph.FlacMetadataBlockHeaderReadResult right) { }
        public static bool operator ==(TagLibSharp2.Xiph.FlacMetadataBlockHeaderReadResult left, TagLibSharp2.Xiph.FlacMetadataBlockHeaderReadResult right) { }
    }
    public sealed class FlacPicture : TagLibSharp2.Core.Picture
    {
        public FlacPicture(string mimeType, TagLibSharp2.Core.PictureType pictureType, string description, TagLibSharp2.Core.BinaryData pictureData, uint width, uint height, uint colorDepth, uint colorCount) { }
        public uint ColorCount { get; }
        public uint ColorDepth { get; }
        public override string Description { get; }
        public uint Height { get; }
        public override string MimeType { get; }
        public override TagLibSharp2.Core.BinaryData PictureData { get; }
        public override TagLibSharp2.Core.PictureType PictureType { get; }
        public uint Width { get; }
        public TagLibSharp2.Core.BinaryData RenderContent() { }
        public static TagLibSharp2.Xiph.FlacPicture FromBytes(byte[] imageData, TagLibSharp2.Core.PictureType pictureType = 3, string description = "") { }
        public static TagLibSharp2.Xiph.FlacPicture FromFile(string path, TagLibSharp2.Core.PictureType pictureType = 3, string description = "") { }
        public static TagLibSharp2.Xiph.FlacPictureReadResult Read(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct FlacPictureReadResult : System.IEquatable<TagLibSharp2.Xiph.FlacPictureReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Xiph.FlacPicture? Picture { get; }
        public bool Equals(TagLibSharp2.Xiph.FlacPictureReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Xiph.FlacPictureReadResult Failure(string error) { }
        public static TagLibSharp2.Xiph.FlacPictureReadResult Success(TagLibSharp2.Xiph.FlacPicture picture, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Xiph.FlacPictureReadResult left, TagLibSharp2.Xiph.FlacPictureReadResult right) { }
        public static bool operator ==(TagLibSharp2.Xiph.FlacPictureReadResult left, TagLibSharp2.Xiph.FlacPictureReadResult right) { }
    }
    public readonly struct FlacPreservedBlock : System.IEquatable<TagLibSharp2.Xiph.FlacPreservedBlock>
    {
        public FlacPreservedBlock(TagLibSharp2.Xiph.FlacBlockType blockType, TagLibSharp2.Core.BinaryData data) { }
        public TagLibSharp2.Xiph.FlacBlockType BlockType { get; }
        public TagLibSharp2.Core.BinaryData Data { get; }
        public bool Equals(TagLibSharp2.Xiph.FlacPreservedBlock other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static bool operator !=(TagLibSharp2.Xiph.FlacPreservedBlock left, TagLibSharp2.Xiph.FlacPreservedBlock right) { }
        public static bool operator ==(TagLibSharp2.Xiph.FlacPreservedBlock left, TagLibSharp2.Xiph.FlacPreservedBlock right) { }
    }
    public sealed class VorbisComment : TagLibSharp2.Core.Tag
    {
        public VorbisComment() { }
        public VorbisComment(string vendorString) { }
        public override string? AcoustIdFingerprint { get; set; }
        public override string? AcoustIdId { get; set; }
        public override string? Album { get; set; }
        public override string? AlbumArtist { get; set; }
        public override string? AlbumArtistSort { get; set; }
        public override string[] AlbumArtists { get; set; }
        public override string[]? AlbumArtistsSort { get; set; }
        public override string? AlbumSort { get; set; }
        public override string? AmazonId { get; set; }
        public override string? Artist { get; set; }
        public override string? ArtistSort { get; set; }
        public override string? Barcode { get; set; }
        public override uint? BeatsPerMinute { get; set; }
        public override string? CatalogNumber { get; set; }
        public override string? Comment { get; set; }
        public override string? Composer { get; set; }
        public override string? ComposerSort { get; set; }
        public override string[] Composers { get; set; }
        public override string[]? ComposersSort { get; set; }
        public override string? Conductor { get; set; }
        public override string? Copyright { get; set; }
        public override string? DateTagged { get; set; }
        public override string? Description { get; set; }
        public override uint? DiscNumber { get; set; }
        public override string? DiscSubtitle { get; set; }
        public override string? EncodedBy { get; set; }
        public override string? EncoderSettings { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Xiph.VorbisCommentField> Fields { get; }
        public override string? Genre { get; set; }
        public override string[] Genres { get; set; }
        public override string? Grouping { get; set; }
        public override string? InitialKey { get; set; }
        public override bool IsCompilation { get; set; }
        public override string? Isrc { get; set; }
        public override string? Language { get; set; }
        public override string? Lyrics { get; set; }
        public override string? MediaType { get; set; }
        public override string? Mood { get; set; }
        public override string? Movement { get; set; }
        public override uint? MovementNumber { get; set; }
        public override uint? MovementTotal { get; set; }
        public override string? MusicBrainzAlbumArtistId { get; set; }
        public override string? MusicBrainzArtistId { get; set; }
        public override string? MusicBrainzDiscId { get; set; }
        public override string? MusicBrainzRecordingId { get; set; }
        public override string? MusicBrainzReleaseCountry { get; set; }
        public override string? MusicBrainzReleaseGroupId { get; set; }
        public override string? MusicBrainzReleaseId { get; set; }
        public override string? MusicBrainzReleaseStatus { get; set; }
        public override string? MusicBrainzReleaseType { get; set; }
        public override string? MusicBrainzTrackId { get; set; }
        public override string? MusicBrainzWorkId { get; set; }
        public override string? OriginalReleaseDate { get; set; }
        public override string[] Performers { get; set; }
        public override string[]? PerformersRole { get; set; }
        public override string[]? PerformersSort { get; set; }
        public System.Collections.Generic.IReadOnlyList<TagLibSharp2.Xiph.FlacPicture> PictureBlocks { get; }
        public override TagLibSharp2.Core.IPicture[] Pictures { get; set; }
        public override string? PodcastFeedUrl { get; set; }
        public override string? Publisher { get; set; }
        public override string? R128AlbumGain { get; set; }
        public override string? R128TrackGain { get; set; }
        public override string? Remixer { get; set; }
        public override string? ReplayGainAlbumGain { get; set; }
        public override string? ReplayGainAlbumPeak { get; set; }
        public override string? ReplayGainTrackGain { get; set; }
        public override string? ReplayGainTrackPeak { get; set; }
        public override string? Subtitle { get; set; }
        public override TagLibSharp2.Core.TagTypes TagType { get; }
        public override string? Title { get; set; }
        public override string? TitleSort { get; set; }
        public override uint? TotalDiscs { get; set; }
        public override uint? TotalTracks { get; set; }
        public override uint? Track { get; set; }
        public string VendorString { get; set; }
        public override string? Work { get; set; }
        public override string? Year { get; set; }
        public void AddField(string name, string value) { }
        public void AddPicture(TagLibSharp2.Xiph.FlacPicture picture) { }
        public override void Clear() { }
        public string? GetValue(string name) { }
        public System.Collections.Generic.IReadOnlyList<string> GetValues(string name) { }
        public void RemoveAll(string name) { }
        public void RemoveAllPictures() { }
        public void RemovePictures(TagLibSharp2.Core.PictureType pictureType) { }
        public override TagLibSharp2.Core.BinaryData Render() { }
        public void SetValue(string name, string? value) { }
        public static TagLibSharp2.Xiph.VorbisCommentReadResult Read(System.ReadOnlySpan<byte> data) { }
    }
    public readonly struct VorbisCommentField : System.IEquatable<TagLibSharp2.Xiph.VorbisCommentField>
    {
        public VorbisCommentField(string name, string value) { }
        public string Name { get; }
        public string Value { get; }
        public bool Equals(TagLibSharp2.Xiph.VorbisCommentField other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public override string ToString() { }
        public static TagLibSharp2.Xiph.VorbisCommentFieldParseResult Parse(string fieldString) { }
        public static bool operator !=(TagLibSharp2.Xiph.VorbisCommentField left, TagLibSharp2.Xiph.VorbisCommentField right) { }
        public static bool operator ==(TagLibSharp2.Xiph.VorbisCommentField left, TagLibSharp2.Xiph.VorbisCommentField right) { }
    }
    public readonly struct VorbisCommentFieldParseResult : System.IEquatable<TagLibSharp2.Xiph.VorbisCommentFieldParseResult>
    {
        public string? Error { get; }
        public TagLibSharp2.Xiph.VorbisCommentField Field { get; }
        public bool IsSuccess { get; }
        public bool Equals(TagLibSharp2.Xiph.VorbisCommentFieldParseResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Xiph.VorbisCommentFieldParseResult Failure(string error) { }
        public static TagLibSharp2.Xiph.VorbisCommentFieldParseResult Success(TagLibSharp2.Xiph.VorbisCommentField field) { }
        public static bool operator !=(TagLibSharp2.Xiph.VorbisCommentFieldParseResult left, TagLibSharp2.Xiph.VorbisCommentFieldParseResult right) { }
        public static bool operator ==(TagLibSharp2.Xiph.VorbisCommentFieldParseResult left, TagLibSharp2.Xiph.VorbisCommentFieldParseResult right) { }
    }
    public readonly struct VorbisCommentReadResult : System.IEquatable<TagLibSharp2.Xiph.VorbisCommentReadResult>
    {
        public int BytesConsumed { get; }
        public string? Error { get; }
        public bool IsSuccess { get; }
        public TagLibSharp2.Xiph.VorbisComment? Tag { get; }
        public bool Equals(TagLibSharp2.Xiph.VorbisCommentReadResult other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public static TagLibSharp2.Xiph.VorbisCommentReadResult Failure(string error) { }
        public static TagLibSharp2.Xiph.VorbisCommentReadResult Success(TagLibSharp2.Xiph.VorbisComment tag, int bytesConsumed) { }
        public static bool operator !=(TagLibSharp2.Xiph.VorbisCommentReadResult left, TagLibSharp2.Xiph.VorbisCommentReadResult right) { }
        public static bool operator ==(TagLibSharp2.Xiph.VorbisCommentReadResult left, TagLibSharp2.Xiph.VorbisCommentReadResult right) { }
    }
}